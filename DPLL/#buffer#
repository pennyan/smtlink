
[~/.emacs.d] [ 10 files 104Kb ]
[11:36:11 yanpeng] .emacs.d $ cd proof
bash: cd: proof: No such file or directory

[~/.emacs.d] [ 10 files 104Kb ]
[11:37:24 yanpeng] .emacs.d $ cd ..

[~] [ 32 files 616Kb ]
[11:37:29 yanpeng] ~ $ ls
#.bashrc#                   htop                         sent
bin                         htop-1.0.1-2.1.2.x86_64.rpm  Sent Messages
C:\nppdf32Log\debuglog.txt  #.ido.last#                  software
commands                    Mail                         Templates
deja-dup                    Music                        test.txt
Desktop                     Notes                        tmux.bash
Documents                   Pictures                     usr
Downloads                   postponed                    var
Drafts                      project                      Videos
#Drafts#                    Public                       WINDOWS
emacs-config                public_html

[~] [ 32 files 616Kb ]
[11:37:29 yanpeng] ~ $ cd project

[~/project] [ 2 files 16Kb ]
[11:37:31 yanpeng] project $ ls
ACL2  codechef

[~/project] [ 2 files 16Kb ]
[11:37:31 yanpeng] project $ cd ACL2

[~/project/ACL2] [ 5 files 28Kb ]
[11:37:32 yanpeng] ACL2(branch:ACL22Z3) $ ls
clause-processor-test  DPLL  README  smtlink  test_bitBucket

[~/project/ACL2] [ 5 files 28Kb ]
[11:37:33 yanpeng] ACL2(branch:ACL22Z3) $ cd DPL
bash: cd: DPL: No such file or directory

[~/project/ACL2] [ 5 files 28Kb ]
[11:37:34 yanpeng] ACL2(branch:ACL22Z3) $ cd DIRECTORY
bash: cd: DIRECTORY: No such file or directory

[~/project/ACL2] [ 5 files 28Kb ]
[11:37:36 yanpeng] ACL2(branch:ACL22Z3) $ cd ..

[~/project] [ 2 files 16Kb ]
[11:37:38 yanpeng] project $ ls
ACL2  codechef

[~/project] [ 2 files 16Kb ]
[11:37:38 yanpeng] project $ cd ACL2

[~/project/ACL2] [ 5 files 28Kb ]
[11:37:41 yanpeng] ACL2(branch:ACL22Z3) $ ls
clause-processor-test  DPLL  README  smtlink  test_bitBucket

[~/project/ACL2] [ 5 files 28Kb ]
[11:37:42 yanpeng] ACL2(branch:ACL22Z3) $ cd DPLL

[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[11:37:43 yanpeng] DPLL $ ls
#DPLL_functions.lisp#  DPLL-theorems.lisp  foo.lisp     summation.lisp
DPLL-functions.lisp    expanded            global.lisp  z3_files

[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[11:37:44 yanpeng] DPLL $ ec
*ERROR*: Terminal type "dumb" is not powerful enough to run Emacs

[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[11:37:45 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.07 seconds (prove: 0.00, print: 0.00, other: 0.07)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
Since B-TERM is non-recursive, its admission is trivial.  We observe
that the type of B-TERM is described by the theorem 
(ACL2-NUMBERP (B-TERM H)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN B-TERM ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B-TERM
ACL2 !>>
For the admission of B-SUM we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(IF (OR (NOT (INTEGERP H_LO))
        (NOT (INTEGERP H_HI))
        (< H_HI H_LO))
    0 (+ 1 H_HI (- H_LO))).
  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (IF (OR (NOT (INTEGERP H_LO))
                  (NOT (INTEGERP H_HI))
                  (< H_HI H_LO))
              0 (+ 1 H_HI (- H_LO))))
     (IMPLIES (NOT (OR (NOT (INTEGERP H_HI))
                       (NOT (INTEGERP H_LO))
                       (< H_HI H_LO)))
              (O< (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP (+ -1 H_HI)))
                          (< (+ -1 H_HI) H_LO))
                      0 (+ 1 (+ -1 H_HI) (- H_LO)))
                  (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP H_HI))
                          (< H_HI H_LO))
                      0 (+ 1 H_HI (- H_LO)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O-P))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for B-SUM.  Thus, we
admit this function under the principle of definition.  We observe
that the type of B-SUM is described by the theorem 
(ACL2-NUMBERP (B-SUM H_LO H_HI)).  We used primitive type reasoning
and the :type-prescription rule B-TERM.

Summary
Form:  ( DEFUN B-SUM ...)
Rules: ((:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O-P)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE MINUS-CANCELLATION-ON-LEFT)
        (:REWRITE NATP-RW)
        (:TYPE-PRESCRIPTION B-TERM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NOT)
             (:DEFINITION O-P)
             (:DEFINITION O<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 B-SUM
ACL2 !>>
Since B is non-recursive, its admission is trivial.  We observe that
the type of B is described by the theorem (ACL2-NUMBERP (B N)).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN B ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B
ACL2 !>>
ACL2 Warning [Non-rec] in ( DEFTHM B-TERM-NEG ...):  A :REWRITE rule
generated from B-TERM-NEG will be triggered only by terms containing
the non-recursive function symbol B-TERM.  Unless this function is
disabled, this rule is unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(IMPLIES (AND (INTEGERP H) (< 0 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* (EXPT 2 H)
                     (DENOMINATOR (/ (EXPT 2 H)))))
               (* 2 (EXPT 2 H)
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (/ (EXPT 2 H)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (EXPT '2 H).  This
suggestion was produced using the :induction rule EXPT.  If we let
(:P H) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ZIP H))
                   (NOT (= (FIX 2) 0))
                   (<= H 0)
                   (:P (+ H 1)))
              (:P H))
     (IMPLIES (AND (NOT (ZIP H))
                   (NOT (= (FIX 2) 0))
                   (< 0 H)
                   (:P (+ H -1)))
              (:P H))
     (IMPLIES (AND (NOT (ZIP H)) (= (FIX 2) 0))
              (:P H))
     (IMPLIES (ZIP H) (:P H))).
This induction is justified by the same argument used to admit EXPT.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'
Subgoal *1/5'10'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(IMPLIES (AND (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 H)))))
                    (- (* (EXPT 2 (+ -1 H))
                          (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                    (* 2 (EXPT 2 (+ -1 H))
                       (/ (+ 6399/3200 (* 1/3200 H)))
                       (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                 1)
              (INTEGERP H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* 2 (EXPT 2 (+ -1 H))
                     (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
               (* 4 (EXPT 2 (+ -1 H))
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
            1))

*1.1 (Subgoal *1/5'10') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(IMPLIES (AND (RATIONALP K)
              (< 0 K)
              (INTEGERP J)
              (< 0 J)
              (RATIONALP S)
              (< S 0)
              (INTEGERP I)
              (<= 0 I)
              (RATIONALP R)
              (< 0 R)
              (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 S)))
                    (- (* J (DENOMINATOR K)))
                    (* 2 J (DENOMINATOR K)
                       (/ (+ 6399/3200 R))))
                 1)
              (INTEGERP H))
         (< (+ (* 2 (/ (+ 2 S)))
               (- (* 2 J (DENOMINATOR (* 1/2 K))))
               (* 4 J (/ (+ 2 R))
                  (DENOMINATOR (* 1/2 K))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( DEFTHM B-TERM-NEG ...)
Rules: ((:COMPOUND-RECOGNIZER ZIP-COMPOUND-RECOGNIZER)
        (:DEFINITION B-TERM)
        (:DEFINITION EXPT)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION SIGNUM)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART =)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART BINARY-*)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART DENOMINATOR)
        (:EXECUTABLE-COUNTERPART EQU-C)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART EXPT)
        (:EXECUTABLE-COUNTERPART FIX)
        (:EXECUTABLE-COUNTERPART GAMMA)
        (:EXECUTABLE-COUNTERPART INTEGERP)
        (:EXECUTABLE-COUNTERPART MU)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART RATIONALP)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:EXECUTABLE-COUNTERPART UNARY-/)
        (:EXECUTABLE-COUNTERPART ZIP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-INTEGERP)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-NONZERO)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-POSITIVE)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-RATIONALP)
        (:INDUCTION EXPT)
        (:REWRITE /-CANCELLATION-ON-LEFT)
        (:REWRITE /R-WHEN-ABS-NUMERATOR=1)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE <-0-+-NEGATIVE-2)
        (:REWRITE <-UNARY-/-POSITIVE-RIGHT)
        (:REWRITE ASSOCIATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY)
        (:REWRITE DISTRIBUTIVITY-OF-/-OVER-*)
        (:REWRITE DISTRIBUTIVITY-OF-MINUS-OVER-+)
        (:REWRITE EXPT-MINUS)
        (:REWRITE FOLD-CONSTS-IN-*)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-EXPT-/-BASE)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-LEFT)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-RIGHT)
        (:REWRITE FUNCTIONAL-SELF-INVERSION-OF-MINUS)
        (:REWRITE NUMERATOR-/X)
        (:REWRITE UNICITY-OF-0)
        (:REWRITE UNICITY-OF-1)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-INTEGERP)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-NONZERO)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-POSITIVE))
Warnings:  Non-rec
Time:  0.13 seconds (prove: 0.13, print: 0.00, other: 0.00)
Prover steps counted:  7456

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(IMPLIES (AND (INTEGERP H) (< 0 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* (EXPT 2 H)
                     (DENOMINATOR (/ (EXPT 2 H)))))
               (* 2 (EXPT 2 H)
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (/ (EXPT 2 H)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(IMPLIES (AND (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 H)))))
                    (- (* (EXPT 2 (+ -1 H))
                          (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                    (* 2 (EXPT 2 (+ -1 H))
                       (/ (+ 6399/3200 (* 1/3200 H)))
                       (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                 1)
              (INTEGERP H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* 2 (EXPT 2 (+ -1 H))
                     (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
               (* 4 (EXPT 2 (+ -1 H))
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
            1))

ACL2 Error in ( DEFTHM B-TERM-NEG ...):  See :DOC failure.

******** FAILED ********
 (:STOP-LD 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:37:08 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
Since B-TERM is non-recursive, its admission is trivial.  We observe
that the type of B-TERM is described by the theorem 
(ACL2-NUMBERP (B-TERM H)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN B-TERM ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B-TERM
ACL2 !>>
For the admission of B-SUM we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(IF (OR (NOT (INTEGERP H_LO))
        (NOT (INTEGERP H_HI))
        (< H_HI H_LO))
    0 (+ 1 H_HI (- H_LO))).
  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (IF (OR (NOT (INTEGERP H_LO))
                  (NOT (INTEGERP H_HI))
                  (< H_HI H_LO))
              0 (+ 1 H_HI (- H_LO))))
     (IMPLIES (NOT (OR (NOT (INTEGERP H_HI))
                       (NOT (INTEGERP H_LO))
                       (< H_HI H_LO)))
              (O< (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP (+ -1 H_HI)))
                          (< (+ -1 H_HI) H_LO))
                      0 (+ 1 (+ -1 H_HI) (- H_LO)))
                  (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP H_HI))
                          (< H_HI H_LO))
                      0 (+ 1 H_HI (- H_LO)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O-P))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for B-SUM.  Thus, we
admit this function under the principle of definition.  We observe
that the type of B-SUM is described by the theorem 
(ACL2-NUMBERP (B-SUM H_LO H_HI)).  We used primitive type reasoning
and the :type-prescription rule B-TERM.

Summary
Form:  ( DEFUN B-SUM ...)
Rules: ((:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O-P)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE MINUS-CANCELLATION-ON-LEFT)
        (:REWRITE NATP-RW)
        (:TYPE-PRESCRIPTION B-TERM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NOT)
             (:DEFINITION O-P)
             (:DEFINITION O<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 B-SUM
ACL2 !>>
Since B is non-recursive, its admission is trivial.  We observe that
the type of B is described by the theorem (ACL2-NUMBERP (B N)).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN B ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B
ACL2 !>>
ACL2 Warning [Non-rec] in ( DEFTHM B-TERM-NEG ...):  A :REWRITE rule
generated from B-TERM-NEG will be triggered only by terms containing
the non-recursive function symbol B-TERM.  Unless this function is
disabled, this rule is unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(IMPLIES (AND (INTEGERP H) (< 0 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* (EXPT 2 H)
                     (DENOMINATOR (/ (EXPT 2 H)))))
               (* 2 (EXPT 2 H)
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (/ (EXPT 2 H)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (EXPT '2 H).  This
suggestion was produced using the :induction rule EXPT.  If we let
(:P H) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ZIP H))
                   (NOT (= (FIX 2) 0))
                   (<= H 0)
                   (:P (+ H 1)))
              (:P H))
     (IMPLIES (AND (NOT (ZIP H))
                   (NOT (= (FIX 2) 0))
                   (< 0 H)
                   (:P (+ H -1)))
              (:P H))
     (IMPLIES (AND (NOT (ZIP H)) (= (FIX 2) 0))
              (:P H))
     (IMPLIES (ZIP H) (:P H))).
This induction is justified by the same argument used to admit EXPT.
When applied to the goal at hand the above induction scheme produces
five nontautological subgoals.
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'
Subgoal *1/5'10'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(IMPLIES (AND (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 H)))))
                    (- (* (EXPT 2 (+ -1 H))
                          (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                    (* 2 (EXPT 2 (+ -1 H))
                       (/ (+ 6399/3200 (* 1/3200 H)))
                       (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                 1)
              (INTEGERP H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* 2 (EXPT 2 (+ -1 H))
                     (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
               (* 4 (EXPT 2 (+ -1 H))
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
            1))

*1.1 (Subgoal *1/5'10') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(IMPLIES (AND (RATIONALP K)
              (< 0 K)
 (INTEGERP J)
              (< 0 J)
              (RATIONALP S)
              (< S 0)
              (INTEGERP I)
              (<= 0 I)
              (RATIONALP R)
              (< 0 R)
              (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 S)))
                    (- (* J (DENOMINATOR K)))
                    (* 2 J (DENOMINATOR K)
                       (/ (+ 6399/3200 R))))
                 1)
              (INTEGERP H))
         (< (+ (* 2 (/ (+ 2 S)))
               (- (* 2 J (DENOMINATOR (* 1/2 K))))
               (* 4 J (/ (+ 2 R))
                  (DENOMINATOR (* 1/2 K))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( DEFTHM B-TERM-NEG ...)
Rules: ((:COMPOUND-RECOGNIZER ZIP-COMPOUND-RECOGNIZER)
        (:DEFINITION B-TERM)
        (:DEFINITION EXPT)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION SIGNUM)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART =)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART BINARY-*)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART DENOMINATOR)
        (:EXECUTABLE-COUNTERPART EQU-C)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART EXPT)
        (:EXECUTABLE-COUNTERPART FIX)
        (:EXECUTABLE-COUNTERPART GAMMA)
        (:EXECUTABLE-COUNTERPART INTEGERP)
        (:EXECUTABLE-COUNTERPART MU)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART RATIONALP)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:EXECUTABLE-COUNTERPART UNARY-/)
        (:EXECUTABLE-COUNTERPART ZIP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-INTEGERP)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-NONZERO)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-POSITIVE)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-RATIONALP)
        (:INDUCTION EXPT)
        (:REWRITE /-CANCELLATION-ON-LEFT)
        (:REWRITE /R-WHEN-ABS-NUMERATOR=1)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE <-0-+-NEGATIVE-2)
        (:REWRITE <-UNARY-/-POSITIVE-RIGHT)
        (:REWRITE ASSOCIATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY)
        (:REWRITE DISTRIBUTIVITY-OF-/-OVER-*)
        (:REWRITE DISTRIBUTIVITY-OF-MINUS-OVER-+)
        (:REWRITE EXPT-MINUS)
        (:REWRITE FOLD-CONSTS-IN-*)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-EXPT-/-BASE)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-LEFT)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-RIGHT)
        (:REWRITE FUNCTIONAL-SELF-INVERSION-OF-MINUS)
        (:REWRITE NUMERATOR-/X)
        (:REWRITE UNICITY-OF-0)
        (:REWRITE UNICITY-OF-1)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-INTEGERP)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-NONZERO)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-POSITIVE))
Warnings:  Non-rec
Time:  0.12 seconds (prove: 0.12, print: 0.00, other: 0.00)
Prover steps counted:  7456

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(IMPLIES (AND (INTEGERP H) (< 0 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* (EXPT 2 H)
                     (DENOMINATOR (/ (EXPT 2 H)))))
               (* 2 (EXPT 2 H)
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (/ (EXPT 2 H)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(IMPLIES (AND (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 H)))))
                    (- (* (EXPT 2 (+ -1 H))
                          (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                    (* 2 (EXPT 2 (+ -1 H))
                       (/ (+ 6399/3200 (* 1/3200 H)))
                       (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                 1)
              (INTEGERP H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* 2 (EXPT 2 (+ -1 H))
                     (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
               (* 4 (EXPT 2 (+ -1 H))
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
            1))

ACL2 Error in ( DEFTHM B-TERM-NEG ...):  See :DOC failure.

******** FAILED ********
 (:STOP-LD 2)
ACL2 !>(+ (B 5) (-5))


ACL2 Error in TOP-LEVEL:  Function applications in ACL2 must begin
with a symbol or LAMBDA expression.  (-5) is not of this form.

ACL2 !>(+ (B 5) (B -5))
-233435210267802521243/366503750655464570879808
ACL2 !>(+ (B 3) (B -3))
-19195/163839996
ACL2 !>(+ (B 1) (B -1))
0
ACL2 !>(+ (B 1) (B -1))
0
ACL2 !>(GOOD-BYE)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:40:20 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
Since B-TERM is non-recursive, its admission is trivial.  We observe
that the type of B-TERM is described by the theorem 
(ACL2-NUMBERP (B-TERM H)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN B-TERM ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B-TERM
ACL2 !>>
For the admission of B-SUM we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(IF (OR (NOT (INTEGERP H_LO))
        (NOT (INTEGERP H_HI))
        (< H_HI H_LO))
    0 (+ 1 H_HI (- H_LO))).
  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (IF (OR (NOT (INTEGERP H_LO))
                  (NOT (INTEGERP H_HI))
                  (< H_HI H_LO))
              0 (+ 1 H_HI (- H_LO))))
     (IMPLIES (NOT (OR (NOT (INTEGERP H_HI))
                       (NOT (INTEGERP H_LO))
                       (< H_HI H_LO)))
              (O< (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP (+ -1 H_HI)))
                          (< (+ -1 H_HI) H_LO))
                      0 (+ 1 (+ -1 H_HI) (- H_LO)))
                  (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP H_HI))
                          (< H_HI H_LO))
                      0 (+ 1 H_HI (- H_LO)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O-P))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for B-SUM.  Thus, we
admit this function under the principle of definition.  We observe
that the type of B-SUM is described by the theorem 
(ACL2-NUMBERP (B-SUM H_LO H_HI)).  We used primitive type reasoning
and the :type-prescription rule B-TERM.

Summary
Form:  ( DEFUN B-SUM ...)
Rules: ((:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O-P)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE MINUS-CANCELLATION-ON-LEFT)
        (:REWRITE NATP-RW)
        (:TYPE-PRESCRIPTION B-TERM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NOT)
             (:DEFINITION O-P)
             (:DEFINITION O<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 B-SUM
ACL2 !>>
Since B is non-recursive, its admission is trivial.  We observe that
the type of B is described by the theorem (ACL2-NUMBERP (B N)).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN B ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B
ACL2 !>>
ACL2 Warning [Non-rec] in ( DEFTHM B-TERM-NEG ...):  A :REWRITE rule
generated from B-TERM-NEG will be triggered only by terms containing
the non-recursive function symbol B-TERM.  Unless this function is
disabled, this rule is unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(IMPLIES (AND (INTEGERP H) (< 2 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* (EXPT 2 H)
                     (DENOMINATOR (/ (EXPT 2 H)))))
               (* 2 (EXPT 2 H)
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (/ (EXPT 2 H)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (EXPT '2 H).  This
suggestion was produced using the :induction rule EXPT.  If we let
(:P H) denote *1 above then the induction scheme we'll use is
(AND (IMPLIES (AND (NOT (ZIP H))
                   (NOT (= (FIX 2) 0))
                   (<= H 0)
                   (:P (+ H 1)))
              (:P H))
     (IMPLIES (AND (NOT (ZIP H))
                   (NOT (= (FIX 2) 0))
                   (< 0 H)
                   (:P (+ H -1)))
              (:P H))
     (IMPLIES (AND (NOT (ZIP H)) (= (FIX 2) 0))
              (:P H))
     (IMPLIES (ZIP H) (:P H))).
This induction is justified by the same argument used to admit EXPT.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(IMPLIES (AND (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 H)))))
                    (- (* (EXPT 2 (+ -1 H))
                          (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                    (* 2 (EXPT 2 (+ -1 H))
                       (/ (+ 6399/3200 (* 1/3200 H)))
                       (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                 1)
              (INTEGERP H)
              (< 2 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* 2 (EXPT 2 (+ -1 H))
                     (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
               (* 4 (EXPT 2 (+ -1 H))
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(IMPLIES (AND (RATIONALP K)
              (< 0 K)
              (INTEGERP J)
              (< 0 J)
              (RATIONALP S)
              (< S 0)
              (INTEGERP I)
              (< 0 I)
              (RATIONALP R)
              (< 0 R)
              (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 S)))
                    (- (* J (DENOMINATOR K)))
                    (* 2 J (DENOMINATOR K)
                       (/ (+ 6399/3200 R))))
                 1)
              (INTEGERP H)
              (< 2 H))
         (< (+ (* 2 (/ (+ 2 S)))
               (- (* 2 J (DENOMINATOR (* 1/2 K))))
               (* 4 J (/ (+ 2 R))
                  (DENOMINATOR (* 1/2 K))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( DEFTHM B-TERM-NEG ...)
Rules: ((:COMPOUND-RECOGNIZER ZIP-COMPOUND-RECOGNIZER)
        (:DEFINITION B-TERM)
        (:DEFINITION EXPT)
        (:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION SIGNUM)
        (:DEFINITION SYNP)
        (:EXECUTABLE-COUNTERPART <)
        (:EXECUTABLE-COUNTERPART =)
        (:EXECUTABLE-COUNTERPART ACL2-NUMBERP)
        (:EXECUTABLE-COUNTERPART BINARY-*)
        (:EXECUTABLE-COUNTERPART BINARY-+)
        (:EXECUTABLE-COUNTERPART DENOMINATOR)
        (:EXECUTABLE-COUNTERPART EQU-C)
        (:EXECUTABLE-COUNTERPART EQUAL)
        (:EXECUTABLE-COUNTERPART EXPT)
        (:EXECUTABLE-COUNTERPART FIX)
        (:EXECUTABLE-COUNTERPART GAMMA)
        (:EXECUTABLE-COUNTERPART INTEGERP)
        (:EXECUTABLE-COUNTERPART MU)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART RATIONALP)
        (:EXECUTABLE-COUNTERPART UNARY--)
        (:EXECUTABLE-COUNTERPART UNARY-/)
        (:EXECUTABLE-COUNTERPART ZIP)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-INTEGERP)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-NONZERO)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-POSITIVE)
        (:GENERALIZE EXPT-TYPE-PRESCRIPTION-RATIONALP)
        (:INDUCTION EXPT)
        (:REWRITE /-CANCELLATION-ON-LEFT)
        (:REWRITE /R-WHEN-ABS-NUMERATOR=1)
        (:REWRITE <-+-NEGATIVE-0-1)
        (:REWRITE <-UNARY-/-POSITIVE-RIGHT)
        (:REWRITE ASSOCIATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-*)
        (:REWRITE COMMUTATIVITY-2-OF-+)
        (:REWRITE COMMUTATIVITY-OF-*)
        (:REWRITE COMMUTATIVITY-OF-+)
        (:REWRITE DISTRIBUTIVITY)
        (:REWRITE DISTRIBUTIVITY-OF-/-OVER-*)
        (:REWRITE DISTRIBUTIVITY-OF-MINUS-OVER-+)
        (:REWRITE EXPT-MINUS)
        (:REWRITE FOLD-CONSTS-IN-*)
        (:REWRITE FOLD-CONSTS-IN-+)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-EXPT-/-BASE)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-LEFT)
        (:REWRITE FUNCTIONAL-COMMUTATIVITY-OF-MINUS-*-RIGHT)
        (:REWRITE FUNCTIONAL-SELF-INVERSION-OF-MINUS)
        (:REWRITE NUMERATOR-/X)
        (:REWRITE UNICITY-OF-0)
        (:REWRITE UNICITY-OF-1)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-INTEGERP)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-NONZERO)
        (:TYPE-PRESCRIPTION EXPT-TYPE-PRESCRIPTION-POSITIVE)
        (:TYPE-PRESCRIPTION |x < y  =>  0 < -x+y|)
        (:TYPE-PRESCRIPTION |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.14 seconds (prove: 0.14, print: 0.00, other: 0.00)
Prover steps counted:  7931

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(IMPLIES (AND (INTEGERP H) (< 2 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* (EXPT 2 H)
                     (DENOMINATOR (/ (EXPT 2 H)))))
               (* 2 (EXPT 2 H)
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (/ (EXPT 2 H)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(IMPLIES (AND (< 0 H)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 H)))))
                    (- (* (EXPT 2 (+ -1 H))
                          (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                    (* 2 (EXPT 2 (+ -1 H))
                       (/ (+ 6399/3200 (* 1/3200 H)))
                       (DENOMINATOR (/ (EXPT 2 (+ -1 H))))))
                 1)
              (INTEGERP H)
              (< 2 H))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 H)))))
               (- (* 2 (EXPT 2 (+ -1 H))
                     (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
               (* 4 (EXPT 2 (+ -1 H))
                  (/ (+ 2 (* 1/3200 H)))
                  (DENOMINATOR (* 1/2 (/ (EXPT 2 (+ -1 H)))))))
            1))

ACL2 Error in ( DEFTHM B-TERM-NEG ...):  See :DOC failure.

******** FAILED ********
 (:STOP-LD 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:46:49 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
Since B-TERM is non-recursive, its admission is trivial.  We observe
that the type of B-TERM is described by the theorem 
(ACL2-NUMBERP (B-TERM H)).  We used primitive type reasoning.

Summary
Form:  ( DEFUN B-TERM ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B-TERM
ACL2 !>>
For the admission of B-SUM we will use the relation O< (which is known
to be well-founded on the domain recognized by O-P) and the measure
(IF (OR (NOT (INTEGERP H_LO))
        (NOT (INTEGERP H_HI))
        (< H_HI H_LO))
    0 (+ 1 H_HI (- H_LO))).
  The non-trivial part of the measure conjecture is

Goal
(AND (O-P (IF (OR (NOT (INTEGERP H_LO))
                  (NOT (INTEGERP H_HI))
                  (< H_HI H_LO))
              0 (+ 1 H_HI (- H_LO))))
     (IMPLIES (NOT (OR (NOT (INTEGERP H_HI))
                       (NOT (INTEGERP H_LO))
                       (< H_HI H_LO)))
              (O< (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP (+ -1 H_HI)))
                          (< (+ -1 H_HI) H_LO))
                      0 (+ 1 (+ -1 H_HI) (- H_LO)))
                  (IF (OR (NOT (INTEGERP H_LO))
                          (NOT (INTEGERP H_HI))
                          (< H_HI H_LO))
                      0 (+ 1 H_HI (- H_LO)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O-P))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:DEFINITION NOT) (:DEFINITION O<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for B-SUM.  Thus, we
admit this function under the principle of definition.  We observe
that the type of B-SUM is described by the theorem 
(ACL2-NUMBERP (B-SUM H_LO H_HI)).  We used primitive type reasoning
and the :type-prescription rule B-TERM.

Summary
Form:  ( DEFUN B-SUM ...)
Rules: ((:DEFINITION FIX)
        (:DEFINITION NOT)
        (:DEFINITION O-FINP)
        (:DEFINITION O-P)
        (:DEFINITION O<)
        (:EXECUTABLE-COUNTERPART NATP)
        (:EXECUTABLE-COUNTERPART NOT)
        (:EXECUTABLE-COUNTERPART TAU-SYSTEM)
        (:FAKE-RUNE-FOR-LINEAR NIL)
        (:FAKE-RUNE-FOR-TYPE-SET NIL)
        (:REWRITE ASSOCIATIVITY-OF-+)
        (:REWRITE MINUS-CANCELLATION-ON-LEFT)
        (:REWRITE NATP-RW)
        (:TYPE-PRESCRIPTION B-TERM))
Splitter rules (see :DOC splitter):
  if-intro: ((:DEFINITION NOT)
             (:DEFINITION O-P)
             (:DEFINITION O<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 B-SUM
ACL2 !>>
Since B is non-recursive, its admission is trivial.  We observe that
the type of B is described by the theorem (ACL2-NUMBERP (B N)).  We
used primitive type reasoning.

Summary
Form:  ( DEFUN B ...)
Rules: ((:FAKE-RUNE-FOR-TYPE-SET NIL))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 B
ACL2 !>>
ACL2 Warning [Non-rec] in ( DEFTHM B-TERM-NEG ...):  A :REWRITE rule
generated from B-TERM-NEG will be triggered only by terms containing
the non-recursive function symbol B-TERM.  Unless this function is
disabled, this rule is unlikely ever to be used.



ACL2 Error in ( DEFTHM B-TERM-NEG ...):  The symbol MY-CLAUSE-PROCESSOR
(in package "ACL2") has neither a function nor macro definition in
ACL2.  Please define it.  Note:  this error occurred in the context
(MY-CLAUSE-PROCESSOR CLAUSE
                     '((:EXPAND (GAMMA MU EQU-C))
                       (:PYTHON-FILE "B-term-neg")
                       (:LET (# #))
                       (:HYPOTHESIZE (# # # #)))).
(See :DOC set-iprint to be able to see elided values in this message.)



ACL2 Error in ( DEFTHM B-TERM-NEG ...):  The form 
(MY-CLAUSE-PROCESSOR CLAUSE
                     '((:EXPAND (GAMMA MU EQU-C))
                       (:PYTHON-FILE "B-term-neg")
                       (:LET (# #))
                       (:HYPOTHESIZE (# # # #))))
is not a legal value for a :clause-processor hint because it was not
successfully translated (see error message above).  See :DOC hints.
(See :DOC set-iprint to be able to see elided values in this message.)


Summary
Form:  ( DEFTHM B-TERM-NEG ...)
Rules: NIL
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( DEFTHM B-TERM-NEG ...):  See :DOC failure.

******** FAILED ********
 (:STOP-LD 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:47:03 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.41 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.50 seconds (prove: 0.00, print: 0.00, other: 4.50)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies (if (if (rationalp expt-gamma-minus-h)
                            (if (rationalp expt-gamma-h)
                                (integerp h)
                                'nil)
                            'nil)
                        (if (< '0 expt-gamma-minus-h)
                            (if (< expt-gamma-minus-h '1)
                                (if (< '0 expt-gamma-h)
                                    (if (< expt-gamma-h '1) (< '2 h) 'nil)
                                    'nil)
                                'nil)
                            'nil)
                        'nil)
                    (< (binary-+ (b-term h)
                                 (b-term (unary-- h)))
                       '0))
Expanded(SMT-z3): (implies
                       (if (if (rationalp expt-gamma-minus-h)
                               (if (rationalp expt-gamma-h)
                                   (integerp h)
                                   'nil)
                               'nil)
                           (if (< '0 expt-gamma-minus-h)
                               (if (< expt-gamma-minus-h '1)
                                   (if (< '0 expt-gamma-h)
                                       (if (< expt-gamma-h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                               'nil)
                           'nil)
                       (< (binary-+ (b-term h)
                                    (b-term (unary-- h)))
                          '0))
Final index number: 0
Error(formula): This is not a valid operator: (b-term h)
Error(formula): This is not a valid operator: (b-term (unary-- h))
  File "z3_files/B-term-neg.py", line 5
    EXPT-GAMMA-MINUS-H=s.isReal("EXPT-GAMMA-MINUS-H")
SyntaxError: can't assign to operator
; Z3: `python z3_files/B-term-neg.py`: 0.70 sec, 2,592 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 5"
                 "    EXPT-GAMMA-MINUS-H=s.isReal(\"EXPT-GAMMA-MINUS-H\")"
                 "SyntaxError: can't assign to operator")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.15 seconds (prove: 0.15, print: 0.00, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:49:45 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.38 seconds (prove: 0.00, print: 0.00, other: 4.38)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt-gamma-minus-h)
                    (if (rationalp expt-gamma-h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt-gamma-minus-h)
                    (if (< expt-gamma-minus-h '1)
                        (if (< '0 expt-gamma-h)
                            (if (< expt-gamma-h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                       (unary-- |var0|))
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                       (unary-- |var1|))
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt-gamma-minus-h)
                           (if (rationalp expt-gamma-h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt-gamma-minus-h)
                           (if (< expt-gamma-minus-h '1)
                               (if (< '0 expt-gamma-h)
                                   (if (< expt-gamma-h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var0|))
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var1|))
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (expt
                                               ((lambda
                                                 nil
                                                 (binary-* '1 (unary-/ '2))))
                                               (unary-- |var0|))
Error(formula): This is not a valid operator: (expt
                                               ((lambda
                                                 nil
                                                 (binary-* '1 (unary-/ '2))))
                                               (unary-- |var1|))
  File "z3_files/B-term-neg.py", line 5
    EXPT-GAMMA-MINUS-H=s.isReal("EXPT-GAMMA-MINUS-H")
SyntaxError: can't assign to operator
; Z3: `python z3_files/B-term-neg.py`: 0.08 sec, 2,592 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 5"
                 "    EXPT-GAMMA-MINUS-H=s.isReal(\"EXPT-GAMMA-MINUS-H\")"
                 "SyntaxError: can't assign to operator")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.15 seconds (prove: 0.14, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:52:21 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.42 seconds (prove: 0.00, print: 0.00, other: 4.42)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt-gamma-minus-h)
                    (if (rationalp expt-gamma-h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt-gamma-minus-h)
                    (if (< expt-gamma-minus-h '1)
                        (if (< '0 expt-gamma-h)
                            (if (< expt-gamma-h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt-gamma-h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                       (unary-- |var1|))
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt-gamma-minus-h)
                           (if (rationalp expt-gamma-h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt-gamma-minus-h)
                           (if (< expt-gamma-minus-h '1)
                               (if (< '0 expt-gamma-h)
                                   (if (< expt-gamma-h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt-gamma-h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var1|))
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (expt
                                               ((lambda
                                                 nil
                                                 (binary-* '1 (unary-/ '2))))
                                               (unary-- |var1|))
  File "z3_files/B-term-neg.py", line 5
    EXPT-GAMMA-MINUS-H=s.isReal("EXPT-GAMMA-MINUS-H")
SyntaxError: can't assign to operator
; Z3: `python z3_files/B-term-neg.py`: 0.33 sec, 2,592 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 5"
                 "    EXPT-GAMMA-MINUS-H=s.isReal(\"EXPT-GAMMA-MINUS-H\")"
                 "SyntaxError: can't assign to operator")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.14, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:53:57 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.26 seconds (prove: 0.00, print: 0.00, other: 4.26)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt-gamma-minus-h)
                    (if (rationalp expt-gamma-h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt-gamma-minus-h)
                    (if (< expt-gamma-minus-h '1)
                        (if (< '0 expt-gamma-h)
                            (if (< expt-gamma-h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt-gamma-h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt-gamma-minus-h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt-gamma-minus-h)
                           (if (rationalp expt-gamma-h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt-gamma-minus-h)
                           (if (< expt-gamma-minus-h '1)
                               (if (< '0 expt-gamma-h)
                                   (if (< expt-gamma-h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt-gamma-h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt-gamma-minus-h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
  File "z3_files/B-term-neg.py", line 5
    EXPT-GAMMA-MINUS-H=s.isReal("EXPT-GAMMA-MINUS-H")
SyntaxError: can't assign to operator
; Z3: `python z3_files/B-term-neg.py`: 0.24 sec, 2,592 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 5"
                 "    EXPT-GAMMA-MINUS-H=s.isReal(\"EXPT-GAMMA-MINUS-H\")"
                 "SyntaxError: can't assign to operator")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[14:55:32 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.44 seconds (prove: 0.00, print: 0.00, other: 4.44)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(s.negate(H))),0)
  File "z3_files/B-term-neg.py", line 9, in <lambda>
    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(s.negate(H))),0)
TypeError: <lambda>() takes no arguments (1 given)
; Z3: `python z3_files/B-term-neg.py`: 0.33 sec, 8,960 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(s.negate(H))),0)"
             "  File \"z3_files/B-term-neg.py\", line 9, in <lambda>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(False),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))(False))))))))))(s.negate(H))),0)"
             "TypeError: <lambda>() takes no arguments (1 given)")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.14, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 8 files 60Kb ]
[15:00:09 yanpeng] DPLL $ python
Python 2.7.6 (default, Feb 28 2014, 00:10:26) 
[GCC 4.7.2 20130108 [gcc-4_7-branch revision 195012]] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> from sys import path
>>> path.insert(0,"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface")
from ACL2_translator import to_smt, Q
s = to_smt()
EXPT_GAMMA_MINUS_H=s.isReal("EXPT_GAMMA_MINUS_H")
EXPT_GAMMA_H=s.isReal("EXPT_GAMMA_H")
H=s.isReal("H")

>>> >>> >>> >>> >>> >>> >>> hypothesis=s.ifx(s.lt(0,EXPT_GAMMA_MINUS_H),s.ifx(s.lt(EXPT_GAMMA_MINUS_H,1),s.ifx(s.lt(0,EXPT_GAMMA_H),s.ifx(s.lt(EXPT_GAMMA_H,1),s.lt(2,H),False),False),False),False)
conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))())))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda :s.times(1,s.reciprocal(s.times(1,1))))(),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))())))))))))(s.negate(H))),0)
s.prove(hypothesis, conclusion)

>>> >>> proved
<ACL2_translator.status instance at 0x7fb9848a9128>
>>> >>> quit()
You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:09:32 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>((lambda nil (* 1 2)))
2
ACL2 !>(endp (car nil))
T
ACL2 !>(endp (cdr nil))
T
ACL2 !>(car nil)
NIL
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:17:19 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.33 seconds (prove: 0.00, print: 0.00, other: 4.33)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.15 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  ((lambda
                                    (|var0|)
                                    (binary-*
                                     expt_gamma_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   h)
                                  ((lambda
                                    (|var1|)
                                    (binary-*
                                     expt_gamma_minus_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   (unary-- h)))
                                 '0)))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              h))
                            (implies (if (integerp h) (< '2 h) 'nil)
                                     (< (binary-+ (b-term h)
                                                  (b-term (unary-- h)))
                                        '0)))
                           ((implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_h))
                            (implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_minus_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_minus_h))))

 Success!


ACL2 Error in ( defthm b-term-neg ...):  The :CLAUSE-PROCESSOR hint

  (my-clause-processor
   clause
   '((:expand (b-term gamma mu equ-c))
     (:python-file "B-term-neg")
     (:let
         ((expt_gamma_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var0|))
                        rationalp)
          (expt_gamma_minus_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              rationalp)))
     (:hypothesize ((< expt_gamma_h 1)
                    (> expt_gamma_h 0)
                    (< expt_gamma_minus_h 1)
                    (> expt_gamma_minus_h 0)))))

did not evaluate to a list of clauses, but instead to

  (((not
     ((lambda
       (expt_gamma_h expt_gamma_minus_h h)
       (implies
        (if (if (rationalp expt_gamma_minus_h)
                (if (rationalp expt_gamma_h)
                    (integerp h)
                    'nil)
                'nil)
            (if (< '0 expt_gamma_minus_h)
                (if (< expt_gamma_minus_h '1)
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1) (< '2 h) 'nil)
                        'nil)
                    'nil)
                'nil)
            'nil)
        (<
         (binary-+
          ((lambda
            (|var0|)
            (binary-*
             expt_gamma_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var0| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           h)
          ((lambda
            (|var1|)
            (binary-*
             expt_gamma_minus_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var1| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           (unary-- h)))
         '0)))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var0|))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var1|))
      h))
    (implies (if (integerp h) (< '2 h) 'nil)
             (< (binary-+ (b-term h)
                          (b-term (unary-- h)))
                '0)))
   ((implies (if (integerp h)
                 (if (equal expt_gamma_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var0|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_h))
    (implies (if (integerp h)
                 (if (equal expt_gamma_minus_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var1|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_minus_h))))

which has a member

  ((not
    ((lambda
      (expt_gamma_h expt_gamma_minus_h h)
      (implies
       (if (if (rationalp expt_gamma_minus_h)
               (if (rationalp expt_gamma_h)
                   (integerp h)
                   'nil)
               'nil)
           (if (< '0 expt_gamma_minus_h)
               (if (< expt_gamma_minus_h '1)
                   (if (< '0 expt_gamma_h)
                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                       'nil)
                   'nil)
               'nil)
           'nil)
       (<
        (binary-+
         ((lambda
           (|var0|)
           (binary-*
            expt_gamma_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var0| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          h)
         ((lambda
           (|var1|)
           (binary-*
            expt_gamma_minus_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var1| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          (unary-- h)))
        '0)))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var0|))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var1|))
     h))
   (implies (if (integerp h) (< '2 h) 'nil)
            (< (binary-+ (b-term h)
                         (b-term (unary-- h)))
               '0)))

that contains the following non-termp (see :DOC term):

  (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         (unary-- h)))
       '0)))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var0|))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var1|))
    h))



Summary
Form:  ( defthm b-term-neg ...)
Rules: nil
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)

*** Note: No checkpoints to print. ***

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:22:08 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "../smtlink/test-all.lisp")

ACL2 Version 6.4.  Level 2.  Cbd 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-connect" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "./SMT-connect" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "./SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.37 seconds (prove: 0.00, print: 0.00, other: 4.37)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Summary
Form:  ( defconst *a* ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 *a*
ACL2 !>>
Since bar0 is non-recursive, its admission is trivial.  We observe
that the type of bar0 is described by the theorem (acl2-numberp (bar0 x)).
We used primitive type reasoning.

Summary
Form:  ( defun bar0 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 bar0
ACL2 !>>
ACL2 Warning [Subsume] in ( defthm test0 ...):  The previously added
rule commutativity-of-+ subsumes a newly proposed :rewrite rule generated
from test0, in the sense that the old rule rewrites a more general
target.  Because the new rule will be tried first, it may nonetheless
find application.

Original clause(connect): (implies (if (rationalp x) 't 'nil)
                                   (equal (binary-+ x x)
                                          (binary-* '1 (bar0 x))))
rewritten: (implies (if (rationalp x) 't 'nil)
                    (equal (binary-+ x x)
                           (binary-* '1
                                     ((lambda (|var0|) (binary-* '2 |var0|))
                                      x))))
Expanded(SMT-z3): (implies
                     (if (rationalp x) 't 'nil)
                     (equal (binary-+ x x)
                            (binary-* '1
                                      ((lambda (|var0|) (binary-* '2 |var0|))
                                       x))))
Final index number: 1
proved
; Z3: `python z3_files/test0.py`: 0.12 sec, 2,000 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (rationalp x) 't 'nil)
                              (equal
                                 (binary-+ x x)
                                 (binary-*
                                      '1
                                      ((lambda (|var0|) (binary-* '2 |var0|))
                                       x)))))
                            (implies (if (rationalp x) 't 'nil)
                                     (equal (binary-+ x x)
                                            (binary-* '1 (bar0 x))))))

 Success!
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test0 ...)
Rules: ((:definition bar0)
        (:definition not)
        (:rewrite unicity-of-1))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Subsume
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  62
 test0
ACL2 !>>
Since foo1 is non-recursive, its admission is trivial.  We observe
that the type of foo1 is described by the theorem (acl2-numberp (foo1 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun foo1 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo1
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test1 ...):  A :rewrite rule generated
from test1 will be triggered only by terms containing the non-recursive
function symbol foo1.  Unless this function is disabled, this rule
is unlikely ever to be used.

Original clause(connect): (implies
                               (if (if (rationalp x)
                                       (if (integerp y) (integerp z) 'nil)
                                       'nil)
                                   (if (not (not (< '0 x)))
                                       (if (equal z (binary-+ '3/2 '4))
                                           (if (< y x)
                                               (< y x)
                                               (< (binary-+ y '40/3) x))
                                           'nil)
                                       'nil)
                                   'nil)
                               (< (foo1 x y) (foo1 x (foo1 x z))))
rewritten: (implies (if (if (rationalp x)
                            (if (integerp y) (integerp z) 'nil)
                            'nil)
                        (if (not (not (< '0 x)))
                            (if (equal z (binary-+ '3/2 '4))
                                (if (< y x)
                                    (< y x)
                                    (< (binary-+ y '40/3) x))
                                'nil)
                            'nil)
                        'nil)
                    (< ((lambda (|var0| |var1|)
                                (binary-* |var0| (binary-+ '1 |var1|)))
                        x y)
                       ((lambda (|var2| |var3|)
                                (binary-* |var2| (binary-+ '1 |var3|)))
                        x
                        ((lambda (|var4| |var5|)
                                 (binary-* |var4| (binary-+ '1 |var5|)))
                         x z))))
Expanded(SMT-z3): (implies
                       (if (if (rationalp x)
                               (if (integerp y) (integerp z) 'nil)
                               'nil)
                           (if (not (not (< '0 x)))
                               (if (equal z (binary-+ '3/2 '4))
                                   (if (< y x)
                                       (< y x)
                                       (< (binary-+ y '40/3) x))
                                   'nil)
                               'nil)
                           'nil)
                       (< ((lambda (|var0| |var1|)
                                   (binary-* |var0| (binary-+ '1 |var1|)))
                           x y)
                          ((lambda (|var2| |var3|)
                                   (binary-* |var2| (binary-+ '1 |var3|)))
                           x
                           ((lambda (|var4| |var5|)
                                    (binary-* |var4| (binary-+ '1 |var5|)))
                            x z))))
Final index number: 6
proved
; Z3: `python z3_files/test1.py`: 0.09 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (if (rationalp x)
                                      (if (integerp y) (integerp z) 'nil)
                                      'nil)
                                  (if (not (not (< '0 x)))
                                      (if (equal z (binary-+ '3/2 '4))
                                          (if (< y x)
                                              (< y x)
                                              (< (binary-+ y '40/3) x))
                                          'nil)
                                      'nil)
                                  'nil)
                              (<
                               ((lambda
                                     (|var0| |var1|)
                                     (binary-* |var0| (binary-+ '1 |var1|)))
                                x y)
                               ((lambda
                                     (|var2| |var3|)
                                     (binary-* |var2| (binary-+ '1 |var3|)))
                                x
                                ((lambda
                                      (|var4| |var5|)
                                      (binary-* |var4| (binary-+ '1 |var5|)))
                                 x z)))))
                            (implies
                                 (if (if (rationalp x)
                                         (if (integerp y) (integerp z) 'nil)
                                         'nil)
                                     (if (not (not (< '0 x)))
                                         (if (equal z (binary-+ '3/2 '4))
                                             (if (< y x)
                                                 (< y x)
                                                 (< (binary-+ y '40/3) x))
                                             'nil)
                                         'nil)
                                     'nil)
                                 (< (foo1 x y) (foo1 x (foo1 x z))))))

 Success!
Goal'

Q.E.D.

Summary
Form:  ( defthm test1 ...)
Rules: ((:fake-rune-for-type-set nil))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
 test1
ACL2 !>>
Since foo2 is non-recursive, its admission is trivial.  We observe
that the type of foo2 is described by the theorem (acl2-numberp (foo2 x)).
We used primitive type reasoning.

Summary
Form:  ( defun foo2 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo2
ACL2 !>>
Since bar2 is non-recursive, its admission is trivial.  We observe
that the type of bar2 is described by the theorem (acl2-numberp (bar2 y)).
We used primitive type reasoning.

Summary
Form:  ( defun bar2 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 bar2
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test2 ...):  A :rewrite rule generated
from test2 will be triggered only by terms containing the non-recursive
function symbols bar2 and foo2.  Unless these functions are disabled,
this rule is unlikely ever to be used.

Original clause(connect): (implies (if (rationalp y) (< '1 y) 'nil)
                                   (< '12 (bar2 (foo2 y))))
rewritten: (implies
                (if (rationalp y) (< '1 y) 'nil)
                (< '12
                   ((lambda (|var0|)
                            (binary-* '2
                                      ((lambda (|var1|) (binary-+ |var1| '3))
                                       |var0|)))
                    ((lambda (|var2|) (binary-+ |var2| '3))
                     y))))
Expanded(SMT-z3): (implies
                   (if (rationalp y) (< '1 y) 'nil)
                   (< '12
                      ((lambda
                            (|var0|)
                            (binary-* '2
                                      ((lambda (|var1|) (binary-+ |var1| '3))
                                       |var0|)))
                       ((lambda (|var2|) (binary-+ |var2| '3))
                        y))))
Final index number: 3
proved
; Z3: `python z3_files/test2.py`: 0.09 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (rationalp y) (< '1 y) 'nil)
                              (<
                               '12
                               ((lambda
                                 (|var0|)
                                 (binary-*
                                      '2
                                      ((lambda (|var1|) (binary-+ |var1| '3))
                                       |var0|)))
                                ((lambda (|var2|) (binary-+ |var2| '3))
                                 y)))))
                            (implies (if (rationalp y) (< '1 y) 'nil)
                                     (< '12 (bar2 (foo2 y))))))

 Success!
Goal'

Q.E.D.

Summary
Form:  ( defthm test2 ...)
Rules: ((:definition bar2)
        (:definition foo2)
        (:definition not)
        (:executable-counterpart binary-+)
        (:executable-counterpart tau-system)
        (:rewrite associativity-of-+))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  81
 test2
ACL2 !>>
Since foo3 is non-recursive, its admission is trivial.  We observe
that the type of foo3 is described by the theorem 
(acl2-numberp (foo3 x args)).  We used primitive type reasoning.

Summary
Form:  ( defun foo3 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo3
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test3 ...):  A :rewrite rule generated
from test3 will be triggered only by terms containing the non-recursive
function symbol foo3.  Unless this function is disabled, this rule
is unlikely ever to be used.


ACL2 Warning [Free] in ( defthm test3 ...):  A :rewrite rule generated
from test3 contains the free variables i and j.  These variables will
be chosen by searching for instances of (integerp i) and (integerp j)
in the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :rewrite rule.  See :DOC free-
variables.

Original clause(connect): (implies
                               (if (if (rationalp x)
                                       (if (integerp i) (integerp j) 'nil)
                                       'nil)
                                   (if (< '0 x)
                                       (if (< '0 i) (< '0 j) 'nil)
                                       'nil)
                                   'nil)
                               (< '0 (foo3 x '(i j))))
rewritten: (implies (if (if (rationalp x)
                            (if (integerp i) (integerp j) 'nil)
                            'nil)
                        (if (< '0 x)
                            (if (< '0 i) (< '0 j) 'nil)
                            'nil)
                        'nil)
                    (< '0
                       ((lambda (|var0| |var1|)
                                (binary-+ |var0|
                                          (binary-+ (nth '0 |var1|)
                                                    (nth '1 |var1|))))
                        x '(i j))))
Expanded(SMT-z3): (implies (if (if (rationalp x)
                                   (if (integerp i) (integerp j) 'nil)
                                   'nil)
                               (if (< '0 x)
                                   (if (< '0 i) (< '0 j) 'nil)
                                   'nil)
                               'nil)
                           (< '0
                              ((lambda (|var0| |var1|)
                                       (binary-+ |var0|
                                                 (binary-+ (nth '0 |var1|)
                                                           (nth '1 |var1|))))
                               x '(i j))))
Final index number: 2
proved
; Z3: `python z3_files/test3.py`: 0.09 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (if (rationalp x)
                                      (if (integerp i) (integerp j) 'nil)
                                      'nil)
                                  (if (< '0 x)
                                      (if (< '0 i) (< '0 j) 'nil)
                                      'nil)
                                  'nil)
                              (< '0
                                 ((lambda
                                       (|var0| |var1|)
                                       (binary-+ |var0|
                                                 (binary-+ (nth '0 |var1|)
                                                           (nth '1 |var1|))))
                                  x '(i j)))))
                            (implies
                                 (if (if (rationalp x)
                                         (if (integerp i) (integerp j) 'nil)
                                         'nil)
                                     (if (< '0 x)
                                         (if (< '0 i) (< '0 j) 'nil)
                                         'nil)
                                     'nil)
                                 (< '0 (foo3 x '(i j))))))

 Success!
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test3 ...)
Rules: ((:definition fix)
        (:definition foo3)
        (:definition not)
        (:executable-counterpart binary-+)
        (:executable-counterpart nth)
        (:rewrite commutativity-of-+)
        (:rewrite unicity-of-0))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Free and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  360
 test3
ACL2 !>>
Since a4 is non-recursive, its admission is trivial.  We observe that
the type of a4 is described by the theorem (acl2-numberp (a4 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun a4 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 a4
ACL2 !>>
Since b4 is non-recursive, its admission is trivial.  We observe that
the type of b4 is described by the theorem (acl2-numberp (b4 x)). 
We used the :type-prescription rule a4.

Summary
Form:  ( defun b4 ...)
Rules: ((:type-prescription a4))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b4
ACL2 !>>
Since c4 is non-recursive, its admission is trivial.  We observe that
the type of c4 is described by the theorem (acl2-numberp (c4 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun c4 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
 c4
ACL2 !>>
Since d4 is non-recursive, its admission is trivial.  We observe that
the type of d4 is described by the theorem (acl2-numberp (d4 x)). 
We used the :type-prescription rule a4.

Summary
Form:  ( defun d4 ...)
Rules: ((:type-prescription a4))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 d4
ACL2 !>>
Since e4 is non-recursive, its admission is trivial.  We observe that
the type of e4 is described by the theorem (acl2-numberp (e4 x)). 

Summary
Form:  ( defun e4 ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 e4
ACL2 !>>
Since f4 is non-recursive, its admission is trivial.  We observe that
the type of f4 is described by the theorem (acl2-numberp (f4 x y)).
We used the :type-prescription rule c4.

Summary
Form:  ( defun f4 ...)
Rules: ((:type-prescription c4))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 f4
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test4 ...):  A :rewrite rule generated
from test4 will be triggered only by terms containing the non-recursive
function symbols f4, d4, c4, a4 and b4.  Unless these functions are
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (if (rationalp a) (rationalp b) 'nil)
                                       't
                                       'nil)
                                   (not (< (f4 (d4 (c4 a b)) (a4 (b4 a) b))
                                           (a4 (b4 a) b))))
rewritten: (implies (if (if (rationalp a) (rationalp b) 'nil)
                        't
                        'nil)
                    (not (< ((lambda (|var0| |var1|)
                                     ((lambda (|var2| |var3|)
                                              (binary-+ |var2| |var3|))
                                      |var0|
                                      ((lambda (|var4|) (unary-- |var4|))
                                       |var1|)))
                             ((lambda (|var5|)
                                      ((lambda (|var6| |var7|)
                                               (binary-* |var6| |var7|))
                                       |var5| |var5|))
                              ((lambda (|var8| |var9|)
                                       (binary-+ |var8| |var9|))
                               a b))
                             ((lambda (|var10| |var11|)
                                      (binary-* |var10| |var11|))
                              ((lambda (|var12|)
                                       ((lambda (|var13| |var14|)
                                                (binary-* |var13| |var14|))
                                        '2
                                        |var12|))
                               a)
                              b))
                            ((lambda (|var15| |var16|)
                                     (binary-* |var15| |var16|))
                             ((lambda (|var17|)
                                      ((lambda (|var18| |var19|)
                                               (binary-* |var18| |var19|))
                                       '2
                                       |var17|))
                              a)
                             b))))
Expanded(SMT-z3): (implies
                      (if (if (rationalp a) (rationalp b) 'nil)
                          't
                          'nil)
                      (not (< ((lambda (|var0| |var1|)
                                       ((lambda (|var2| |var3|)
                                                (binary-+ |var2| |var3|))
                                        |var0|
                                        ((lambda (|var4|) (unary-- |var4|))
                                         |var1|)))
                               ((lambda (|var5|)
                                        ((lambda (|var6| |var7|)
                                                 (binary-* |var6| |var7|))
                                         |var5| |var5|))
                                ((lambda (|var8| |var9|)
                                         (binary-+ |var8| |var9|))
                                 a b))
                               ((lambda (|var10| |var11|)
                                        (binary-* |var10| |var11|))
                                ((lambda (|var12|)
                                         ((lambda (|var13| |var14|)
                                                  (binary-* |var13| |var14|))
                                          '2
                                          |var12|))
                                 a)
                                b))
                              ((lambda (|var15| |var16|)
                                       (binary-* |var15| |var16|))
                               ((lambda (|var17|)
                                        ((lambda (|var18| |var19|)
                                                 (binary-* |var18| |var19|))
                                         '2
                                         |var17|))
                                a)
                               b))))
Final index number: 20
proved
; Z3: `python z3_files/test4.py`: 0.09 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (if (rationalp a) (rationalp b) 'nil)
                                  't
                                  'nil)
                              (not
                               (<
                                ((lambda (|var0| |var1|)
                                         ((lambda (|var2| |var3|)
                                                  (binary-+ |var2| |var3|))
                                          |var0|
                                          ((lambda (|var4|) (unary-- |var4|))
                                           |var1|)))
                                 ((lambda (|var5|)
                                          ((lambda (|var6| |var7|)
                                                   (binary-* |var6| |var7|))
                                           |var5| |var5|))
                                  ((lambda (|var8| |var9|)
                                           (binary-+ |var8| |var9|))
                                   a b))
                                 ((lambda (|var10| |var11|)
                                          (binary-* |var10| |var11|))
                                  ((lambda
                                        (|var12|)
                                        ((lambda (|var13| |var14|)
                                                 (binary-* |var13| |var14|))
                                         '2
                                         |var12|))
                                   a)
                                  b))
                                ((lambda (|var15| |var16|)
                                         (binary-* |var15| |var16|))
                                 ((lambda
                                       (|var17|)
                                       ((lambda (|var18| |var19|)
                                                (binary-* |var18| |var19|))
                                        '2
                                        |var17|))
                                  a)
                                 b)))))
                            (implies
                                 (if (if (rationalp a) (rationalp b) 'nil)
                                     't
                                     'nil)
                                 (not (< (f4 (d4 (c4 a b)) (a4 (b4 a) b))
                                         (a4 (b4 a) b))))))

 Success!
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test4 ...)
Rules: ((:definition a4)
        (:definition b4)
        (:definition c4)
        (:definition d4)
        (:definition e4)
        (:definition f4)
        (:definition not)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  527
 test4
ACL2 !>>
Since a6 is non-recursive, its admission is trivial.  We observe that
the type of a6 is described by the theorem (acl2-numberp (a6 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun a6 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 a6
ACL2 !>>
Since b6 is non-recursive, its admission is trivial.  We observe that
the type of b6 is described by the theorem (acl2-numberp (b6 x)). 
We used the :type-prescription rule a6.

Summary
Form:  ( defun b6 ...)
Rules: ((:type-prescription a6))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b6
ACL2 !>>
Since c6 is non-recursive, its admission is trivial.  We observe that
the type of c6 is described by the theorem (acl2-numberp (c6 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun c6 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 c6
ACL2 !>>
Since d6 is non-recursive, its admission is trivial.  We observe that
the type of d6 is described by the theorem (acl2-numberp (d6 x)). 
We used the :type-prescription rule a6.

Summary
Form:  ( defun d6 ...)
Rules: ((:type-prescription a6))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 d6
ACL2 !>>
Since e6 is non-recursive, its admission is trivial.  We observe that
the type of e6 is described by the theorem (acl2-numberp (e6 x)). 

Summary
Form:  ( defun e6 ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 e6
ACL2 !>>
Since f6 is non-recursive, its admission is trivial.  We observe that
the type of f6 is described by the theorem (acl2-numberp (f6 x y)).
We used the :type-prescription rule c6.

Summary
Form:  ( defun f6 ...)
Rules: ((:type-prescription c6))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 f6
ACL2 !>>
Since foo6 is non-recursive, its admission is trivial.  We observe
that the type of foo6 is described by the theorem (acl2-numberp (foo6 x n)).
We used the :type-prescription rule expt.

Summary
Form:  ( defun foo6 ...)
Rules: ((:type-prescription expt))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo6
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test6 ...):  A :rewrite rule generated
from test6 will be triggered only by terms containing the non-recursive
function symbols f6, d6, c6, foo6, a6 and b6.  Unless these functions
are disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies
                           (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (< '0 gamma)
                                  (if (< gamma '1)
                                      (if (< '0 m) (< m n) 'nil)
                                      'nil)
                                  'nil)
                              'nil)
                           (not (< (a6 (expt gamma m)
                                       (f6 (d6 (c6 a b)) (a6 (b6 a) b)))
                                   (a6 (foo6 gamma n) (a6 (b6 a) b)))))
rewritten: (implies
                (if (if (rationalp expt_gamma_n)
                        (if (rationalp expt_gamma_m)
                            (if (rationalp a)
                                (if (rationalp b)
                                    (if (rationalp gamma)
                                        (if (integerp m) (integerp n) 'nil)
                                        'nil)
                                    'nil)
                                'nil)
                            'nil)
                        'nil)
                    (if (< '0 expt_gamma_n)
                        (if (< '0 expt_gamma_m)
                            (if (< expt_gamma_n expt_gamma_m)
                                (if (< '0 gamma)
                                    (if (< gamma '1)
                                        (if (< '0 m) (< m n) 'nil)
                                        'nil)
                                    'nil)
                                'nil)
                            'nil)
                        'nil)
                    'nil)
                (not (< ((lambda (|var0| |var1|)
                                 (binary-* |var0| |var1|))
                         expt_gamma_m
                         ((lambda (|var2| |var3|)
                                  ((lambda (|var4| |var5|)
                                           (binary-+ |var4| |var5|))
                                   |var2|
                                   ((lambda (|var6|) (unary-- |var6|))
                                    |var3|)))
                          ((lambda (|var7|)
                                   ((lambda (|var8| |var9|)
                                            (binary-* |var8| |var9|))
                                    |var7| |var7|))
                           ((lambda (|var10| |var11|)
                                    (binary-+ |var10| |var11|))
                            a b))
                          ((lambda (|var12| |var13|)
                                   (binary-* |var12| |var13|))
                           ((lambda (|var14|)
                                    ((lambda (|var15| |var16|)
                                             (binary-* |var15| |var16|))
                                     '2
                                     |var14|))
                            a)
                           b)))
                        ((lambda (|var17| |var18|)
                                 (binary-* |var17| |var18|))
                         expt_gamma_n
                         ((lambda (|var21| |var22|)
                                  (binary-* |var21| |var22|))
                          ((lambda (|var23|)
                                   ((lambda (|var24| |var25|)
                                            (binary-* |var24| |var25|))
                                    '2
                                    |var23|))
                           a)
                          b)))))
Expanded(SMT-z3): (implies
                   (if
                      (if (rationalp expt_gamma_n)
                          (if (rationalp expt_gamma_m)
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                          'nil)
                      (if (< '0 expt_gamma_n)
                          (if (< '0 expt_gamma_m)
                              (if (< expt_gamma_n expt_gamma_m)
                                  (if (< '0 gamma)
                                      (if (< gamma '1)
                                          (if (< '0 m) (< m n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                          'nil)
                      'nil)
                   (not (< ((lambda (|var0| |var1|)
                                    (binary-* |var0| |var1|))
                            expt_gamma_m
                            ((lambda (|var2| |var3|)
                                     ((lambda (|var4| |var5|)
                                              (binary-+ |var4| |var5|))
                                      |var2|
                                      ((lambda (|var6|) (unary-- |var6|))
                                       |var3|)))
                             ((lambda (|var7|)
                                      ((lambda (|var8| |var9|)
                                               (binary-* |var8| |var9|))
                                       |var7| |var7|))
                              ((lambda (|var10| |var11|)
                                       (binary-+ |var10| |var11|))
                               a b))
                             ((lambda (|var12| |var13|)
                                      (binary-* |var12| |var13|))
                              ((lambda (|var14|)
                                       ((lambda (|var15| |var16|)
                                                (binary-* |var15| |var16|))
                                        '2
                                        |var14|))
                               a)
                              b)))
                           ((lambda (|var17| |var18|)
                                    (binary-* |var17| |var18|))
                            expt_gamma_n
                            ((lambda (|var21| |var22|)
                                     (binary-* |var21| |var22|))
                             ((lambda (|var23|)
                                      ((lambda (|var24| |var25|)
                                               (binary-* |var24| |var25|))
                                       '2
                                       |var23|))
                              a)
                             b)))))
Final index number: 26
proved
; Z3: `python z3_files/test6.py`: 0.10 sec, 1,808 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_m expt_gamma_n a b gamma m n)
                               (implies
                                (if
                                 (if
                                  (rationalp expt_gamma_n)
                                  (if
                                   (rationalp expt_gamma_m)
                                   (if
                                    (rationalp a)
                                    (if
                                      (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                    'nil)
                                   'nil)
                                  'nil)
                                 (if
                                   (< '0 expt_gamma_n)
                                   (if (< '0 expt_gamma_m)
                                       (if (< expt_gamma_n expt_gamma_m)
                                           (if (< '0 gamma)
                                               (if (< gamma '1)
                                                   (if (< '0 m) (< m n) 'nil)
                                                   'nil)
                                               'nil)
                                           'nil)
                                       'nil)
                                   'nil)
                                 'nil)
                                (not
                                 (<
                                  ((lambda (|var0| |var1|)
                                           (binary-* |var0| |var1|))
                                   expt_gamma_m
                                   ((lambda
                                         (|var2| |var3|)
                                         ((lambda (|var4| |var5|)
                                                  (binary-+ |var4| |var5|))
                                          |var2|
                                          ((lambda (|var6|) (unary-- |var6|))
                                           |var3|)))
                                    ((lambda
                                          (|var7|)
                                          ((lambda (|var8| |var9|)
                                                   (binary-* |var8| |var9|))
                                           |var7| |var7|))
                                     ((lambda (|var10| |var11|)
                                              (binary-+ |var10| |var11|))
                                      a b))
                                    ((lambda (|var12| |var13|)
                                             (binary-* |var12| |var13|))
                                     ((lambda
                                         (|var14|)
                                         ((lambda (|var15| |var16|)
                                                  (binary-* |var15| |var16|))
                                          '2
                                          |var14|))
                                      a)
                                     b)))
                                  ((lambda (|var17| |var18|)
                                           (binary-* |var17| |var18|))
                                   expt_gamma_n
                                   ((lambda (|var21| |var22|)
                                            (binary-* |var21| |var22|))
                                    ((lambda
                                         (|var23|)
                                         ((lambda (|var24| |var25|)
                                                  (binary-* |var24| |var25|))
                                          '2
                                          |var23|))
                                     a)
                                    b))))))
                              (expt gamma m)
                              (expt gamma n)
                              a b gamma m n))
                            (implies
                             (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (< '0 gamma)
                                  (if (< gamma '1)
                                      (if (< '0 m) (< m n) 'nil)
                                      'nil)
                                  'nil)
                              'nil)
                             (not (< (a6 (expt gamma m)
                                         (f6 (d6 (c6 a b)) (a6 (b6 a) b)))
                                     (a6 (foo6 gamma n) (a6 (b6 a) b))))))
                           ((implies
                             (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (equal expt_gamma_m (expt gamma m))
                                  (if (< '0 gamma)
                                      (if (< gamma '1)
                                          (if (< '0 m) (< m n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                             (rationalp expt_gamma_m))
                            (implies
                             (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (equal expt_gamma_n (expt gamma n))
                                  (if (< '0 gamma)
                                      (if (< gamma '1)
                                          (if (< '0 m) (< m n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                             (rationalp expt_gamma_n))))

 Success!
Subgoal 2
Subgoal 2'
Subgoal 1

Q.E.D.

Summary
Form:  ( defthm test6 ...)
Rules: ((:definition a6)
        (:definition b6)
        (:definition c6)
        (:definition d6)
        (:definition e6)
        (:definition f6)
        (:definition foo6)
        (:definition not)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-is-decreasing-for-pos-base<1)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1324
 test6
ACL2 !>>Bye.
 :eof
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:23:02 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.41 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.11 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  ((lambda
                                    (|var0|)
                                    (binary-*
                                     expt_gamma_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   h)
                                  ((lambda
                                    (|var1|)
                                    (binary-*
                                     expt_gamma_minus_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   (unary-- h)))
                                 '0)))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              h))
                            (implies (if (integerp h) (< '2 h) 'nil)
                                     (< (binary-+ (b-term h)
                                                  (b-term (unary-- h)))
                                        '0)))
                           ((implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_h))
                            (implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_minus_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_minus_h))))

 Success!


ACL2 Error in ( defthm b-term-neg ...):  The :CLAUSE-PROCESSOR hint

  (my-clause-processor
   clause
   '((:expand (b-term gamma mu equ-c))
     (:python-file "B-term-neg")
     (:let
         ((expt_gamma_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var0|))
                        rationalp)
          (expt_gamma_minus_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              rationalp)))
     (:hypothesize ((< expt_gamma_h 1)
                    (> expt_gamma_h 0)
                    (< expt_gamma_minus_h 1)
                    (> expt_gamma_minus_h 0)))))

did not evaluate to a list of clauses, but instead to

  (((not
     ((lambda
       (expt_gamma_h expt_gamma_minus_h h)
       (implies
        (if (if (rationalp expt_gamma_minus_h)
                (if (rationalp expt_gamma_h)
                    (integerp h)
                    'nil)
                'nil)
            (if (< '0 expt_gamma_minus_h)
                (if (< expt_gamma_minus_h '1)
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1) (< '2 h) 'nil)
                        'nil)
                    'nil)
                'nil)
            'nil)
        (<
         (binary-+
          ((lambda
            (|var0|)
            (binary-*
             expt_gamma_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var0| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           h)
          ((lambda
            (|var1|)
            (binary-*
             expt_gamma_minus_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var1| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           (unary-- h)))
         '0)))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var0|))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var1|))
      h))
    (implies (if (integerp h) (< '2 h) 'nil)
             (< (binary-+ (b-term h)
                          (b-term (unary-- h)))
                '0)))
   ((implies (if (integerp h)
                 (if (equal expt_gamma_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var0|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_h))
    (implies (if (integerp h)
                 (if (equal expt_gamma_minus_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var1|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_minus_h))))

which has a member

  ((not
    ((lambda
      (expt_gamma_h expt_gamma_minus_h h)
      (implies
       (if (if (rationalp expt_gamma_minus_h)
               (if (rationalp expt_gamma_h)
                   (integerp h)
                   'nil)
               'nil)
           (if (< '0 expt_gamma_minus_h)
               (if (< expt_gamma_minus_h '1)
                   (if (< '0 expt_gamma_h)
                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                       'nil)
                   'nil)
               'nil)
           'nil)
       (<
        (binary-+
         ((lambda
           (|var0|)
           (binary-*
            expt_gamma_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var0| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          h)
         ((lambda
           (|var1|)
           (binary-*
            expt_gamma_minus_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var1| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          (unary-- h)))
        '0)))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var0|))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var1|))
     h))
   (implies (if (integerp h) (< '2 h) 'nil)
            (< (binary-+ (b-term h)
                         (b-term (unary-- h)))
               '0)))

that contains the following non-termp (see :DOC term):

  (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         (unary-- h)))
       '0)))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var0|))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var1|))
    h))



Summary
Form:  ( defthm b-term-neg ...)
Rules: nil
Warnings:  Non-rec
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)

*** Note: No checkpoints to print. ***

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye
)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:24:09 yanpeng] DPLL $ python
Python 2.7.6 (default, Feb 28 2014, 00:10:26) 
[GCC 4.7.2 20130108 [gcc-4_7-branch revision 195012]] on linux2
Type "help", "copyright", "credits" or "license" for more information.
>>> ((lambda ():1+2)())
  File "<stdin>", line 1
    ((lambda ():1+2)())
              ^
SyntaxError: invalid syntax
>>> ((lambda :1+2)())
3
>>> quit()

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:26:29 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.30 seconds (prove: 0.00, print: 0.00, other: 4.30)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.48 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  ((lambda
                                    (|var0|)
                                    (binary-*
                                     expt_gamma_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   h)
                                  ((lambda
                                    (|var1|)
                                    (binary-*
                                     expt_gamma_minus_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   (unary-- h)))
                                 '0)))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              h))
                            (implies (if (integerp h) (< '2 h) 'nil)
                                     (< (binary-+ (b-term h)
                                                  (b-term (unary-- h)))
                                        '0)))
                           ((implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_h))
                            (implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_minus_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_minus_h))))

 Success!


ACL2 Error in ( defthm b-term-neg ...):  The :CLAUSE-PROCESSOR hint

  (my-clause-processor
   clause
   '((:expand (b-term gamma mu equ-c))
     (:python-file "B-term-neg")
     (:let
         ((expt_gamma_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var0|))
                        rationalp)
          (expt_gamma_minus_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              rationalp)))
     (:hypothesize ((< expt_gamma_h 1)
                    (> expt_gamma_h 0)
                    (< expt_gamma_minus_h 1)
                    (> expt_gamma_minus_h 0)))))

did not evaluate to a list of clauses, but instead to

  (((not
     ((lambda
       (expt_gamma_h expt_gamma_minus_h h)
       (implies
        (if (if (rationalp expt_gamma_minus_h)
                (if (rationalp expt_gamma_h)
                    (integerp h)
                    'nil)
                'nil)
            (if (< '0 expt_gamma_minus_h)
                (if (< expt_gamma_minus_h '1)
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1) (< '2 h) 'nil)
                        'nil)
                    'nil)
                'nil)
            'nil)
        (<
         (binary-+
          ((lambda
            (|var0|)
            (binary-*
             expt_gamma_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var0| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           h)
          ((lambda
            (|var1|)
            (binary-*
             expt_gamma_minus_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var1| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           (unary-- h)))
         '0)))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var0|))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var1|))
      h))
    (implies (if (integerp h) (< '2 h) 'nil)
             (< (binary-+ (b-term h)
                          (b-term (unary-- h)))
                '0)))
   ((implies (if (integerp h)
                 (if (equal expt_gamma_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var0|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_h))
    (implies (if (integerp h)
                 (if (equal expt_gamma_minus_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var1|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_minus_h))))

which has a member

  ((not
    ((lambda
      (expt_gamma_h expt_gamma_minus_h h)
      (implies
       (if (if (rationalp expt_gamma_minus_h)
               (if (rationalp expt_gamma_h)
                   (integerp h)
                   'nil)
               'nil)
           (if (< '0 expt_gamma_minus_h)
               (if (< expt_gamma_minus_h '1)
                   (if (< '0 expt_gamma_h)
                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                       'nil)
                   'nil)
               'nil)
           'nil)
       (<
        (binary-+
         ((lambda
           (|var0|)
           (binary-*
            expt_gamma_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var0| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          h)
         ((lambda
           (|var1|)
           (binary-*
            expt_gamma_minus_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var1| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          (unary-- h)))
        '0)))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var0|))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var1|))
     h))
   (implies (if (integerp h) (< '2 h) 'nil)
            (< (binary-+ (b-term h)
                         (b-term (unary-- h)))
               '0)))

that contains the following non-termp (see :DOC term):

  (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         (unary-- h)))
       '0)))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var0|))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var1|))
    h))



Summary
Form:  ( defthm b-term-neg ...)
Rules: nil
Warnings:  Non-rec
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)

*** Note: No checkpoints to print. ***

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:27:06 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)
  File "z3_files/B-term-neg.py", line 9, in <lambda>
    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)
TypeError: <lambda>() takes exactly 1 argument (0 given)
; Z3: `python z3_files/B-term-neg.py`: 0.10 sec, 9,024 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)"
             "  File \"z3_files/B-term-neg.py\", line 9, in <lambda>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda var1:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda QUOTE:s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda QUOTE:s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)"
             "TypeError: <lambda>() takes exactly 1 argument (0 given)")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.15 seconds (prove: 0.15, print: 0.00, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:29:10 yanpeng] DPLL acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.39 seconds (prove: 0.00, print: 0.00, other: 4.39)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))

***********************************************
Note:  Fault during read of memory address #x120000300005
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:34:26 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.43 seconds (prove: 0.00, print: 0.00, other: 4.43)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))

***********************************************
Note:  Fault during read of memory address #x120000300005
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:36:05 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.36 seconds (prove: 0.00, print: 0.00, other: 4.36)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
here
***********************************************
Note:  Fault during read of memory address #x120000300005
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(endp ''nil)
nil
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:41:02 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.37 seconds (prove: 0.00, print: 0.00, other: 4.37)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
Error(helper): list-keys and list-values should be of the same len.Error(helper): list-keys and list-values should be of the same len.rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                nil
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                nil
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       nil
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       nil
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus((lambda  :s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda  :s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)
TypeError: <lambda>() takes no arguments (1 given)
; Z3: `python z3_files/B-term-neg.py`: 0.12 sec, 5,600 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus((lambda  :s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda  :s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)"
             "TypeError: <lambda>() takes no arguments (1 given)")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:42:50 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.39 seconds (prove: 0.00, print: 0.00, other: 4.39)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
Error(helper): list-keys and list-values should be of the same len.Error(helper): list-keys and list-values should be of the same len.rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                'nil
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                'nil
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       'nil
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       'nil
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus((lambda QUOTE,:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda QUOTE,:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)
  File "z3_files/B-term-neg.py", line 9, in <lambda>
    conclusion=s.lt(s.plus((lambda QUOTE,:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda QUOTE,:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)
NameError: global name 'var0' is not defined
; Z3: `python z3_files/B-term-neg.py`: 0.14 sec, 8,880 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus((lambda QUOTE,:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda QUOTE,:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)"
             "  File \"z3_files/B-term-neg.py\", line 9, in <lambda>"
             "    conclusion=s.lt(s.plus((lambda QUOTE,:s.times(EXPT_GAMMA_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(H),(lambda QUOTE,:s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times((lambda  :s.times(1,s.reciprocal(s.times(1,1))))( ),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),(lambda  :s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))( ))))))))))(s.negate(H))),0)"
             "NameError: global name 'var0' is not defined")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:43:34 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   ((lambda nil
                            (binary-* '1
                                      (unary-/ (binary-* '1 '1)))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((lambda
                          nil
                          (binary-+
                           (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                           (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          ((lambda nil
                                   (binary-* '1
                                             (unary-/ (binary-* '1 '1)))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((lambda
                                 nil
                                 (binary-+
                                  (binary-*
                                   (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                   (binary-+ '1 (binary-* '1 '1)))
                                  (unary--
                                      (binary-* '1 (unary-/ '1)))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.09 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  ((lambda
                                    (|var0|)
                                    (binary-*
                                     expt_gamma_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   h)
                                  ((lambda
                                    (|var1|)
                                    (binary-*
                                     expt_gamma_minus_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       ((lambda
                                           nil
                                           (binary-*
                                                '1
                                                (unary-/ (binary-* '1 '1)))))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            ((lambda
                                              nil
                                              (binary-+
                                               (binary-*
                                                (binary-*
                                                 '1
                                                 (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                (binary-+ '1
                                                          (binary-* '1 '1)))
                                               (unary--
                                                (binary-*
                                                   '1
                                                   (unary-/ '1)))))))))))))))
                                   (unary-- h)))
                                 '0)))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|))
                              (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              h))
                            (implies (if (integerp h) (< '2 h) 'nil)
                                     (< (binary-+ (b-term h)
                                                  (b-term (unary-- h)))
                                        '0)))
                           ((implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var0|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_h))
                            (implies
                             (if
                              (integerp h)
                              (if
                               (equal
                                expt_gamma_minus_h
                                (expt
                                    ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|)))
                               (< '2 h)
                               'nil)
                              'nil)
                             (rationalp expt_gamma_minus_h))))

 Success!


ACL2 Error in ( defthm b-term-neg ...):  The :CLAUSE-PROCESSOR hint

  (my-clause-processor
   clause
   '((:expand (b-term gamma mu equ-c))
     (:python-file "B-term-neg")
     (:let
         ((expt_gamma_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                              (unary-- |var0|))
                        rationalp)
          (expt_gamma_minus_h (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                    (unary-- |var1|))
                              rationalp)))
     (:hypothesize ((< expt_gamma_h 1)
                    (> expt_gamma_h 0)
                    (< expt_gamma_minus_h 1)
                    (> expt_gamma_minus_h 0)))))

did not evaluate to a list of clauses, but instead to

  (((not
     ((lambda
       (expt_gamma_h expt_gamma_minus_h h)
       (implies
        (if (if (rationalp expt_gamma_minus_h)
                (if (rationalp expt_gamma_h)
                    (integerp h)
                    'nil)
                'nil)
            (if (< '0 expt_gamma_minus_h)
                (if (< expt_gamma_minus_h '1)
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1) (< '2 h) 'nil)
                        'nil)
                    'nil)
                'nil)
            'nil)
        (<
         (binary-+
          ((lambda
            (|var0|)
            (binary-*
             expt_gamma_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var0| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           h)
          ((lambda
            (|var1|)
            (binary-*
             expt_gamma_minus_h
             (binary-+
              '-1
              (binary-*
               ((lambda nil
                        (binary-* '1
                                  (unary-/ (binary-* '1 '1)))))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var1| '1/3200)
                    ((lambda
                      nil
                      (binary-+
                       (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                       (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
           (unary-- h)))
         '0)))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var0|))
      (expt ((lambda nil (binary-* '1 (unary-/ '2))))
            (unary-- |var1|))
      h))
    (implies (if (integerp h) (< '2 h) 'nil)
             (< (binary-+ (b-term h)
                          (b-term (unary-- h)))
                '0)))
   ((implies (if (integerp h)
                 (if (equal expt_gamma_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var0|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_h))
    (implies (if (integerp h)
                 (if (equal expt_gamma_minus_h
                            (expt ((lambda nil (binary-* '1 (unary-/ '2))))
                                  (unary-- |var1|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_minus_h))))

which has a member

  ((not
    ((lambda
      (expt_gamma_h expt_gamma_minus_h h)
      (implies
       (if (if (rationalp expt_gamma_minus_h)
               (if (rationalp expt_gamma_h)
                   (integerp h)
                   'nil)
               'nil)
           (if (< '0 expt_gamma_minus_h)
               (if (< expt_gamma_minus_h '1)
                   (if (< '0 expt_gamma_h)
                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                       'nil)
                   'nil)
               'nil)
           'nil)
       (<
        (binary-+
         ((lambda
           (|var0|)
           (binary-*
            expt_gamma_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var0| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          h)
         ((lambda
           (|var1|)
           (binary-*
            expt_gamma_minus_h
            (binary-+
             '-1
             (binary-*
              ((lambda nil
                       (binary-* '1
                                 (unary-/ (binary-* '1 '1)))))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var1| '1/3200)
                   ((lambda
                     nil
                     (binary-+
                      (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                      (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
          (unary-- h)))
        '0)))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var0|))
     (expt ((lambda nil (binary-* '1 (unary-/ '2))))
           (unary-- |var1|))
     h))
   (implies (if (integerp h) (< '2 h) 'nil)
            (< (binary-+ (b-term h)
                         (b-term (unary-- h)))
               '0)))

that contains the following non-termp (see :DOC term):

  (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             ((lambda nil
                      (binary-* '1
                                (unary-/ (binary-* '1 '1)))))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  ((lambda
                    nil
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))))
         (unary-- h)))
       '0)))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var0|))
    (expt ((lambda nil (binary-* '1 (unary-/ '2))))
          (unary-- |var1|))
    h))



Summary
Form:  ( defthm b-term-neg ...)
Rules: nil
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)

*** Note: No checkpoints to print. ***

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:52:57 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.41 seconds (prove: 0.00, print: 0.00, other: 4.41)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.00, print: 0.00, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))

***********************************************
Note:  The value NIL is not of the expected type REAL.
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:54:27 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.38 seconds (prove: 0.00, print: 0.00, other: 4.38)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))

***********************************************
Note:  The value NIL is not of the expected type REAL.
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:56:02 yanpeng] DPLL $ acl2

Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 (expt ((binary-* '1 (unary-/ '2)))
                       (unary-- |var0|))
                 (binary-+
                  '-1
                  (binary-*
                   ((binary-* '1
                              (unary-/ (binary-* '1 '1))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((binary-+
                          (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                          (unary-- (binary-* '1 (unary-/ '1))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 (expt ((binary-* '1 (unary-/ '2)))
                       (unary-- |var1|))
                 (binary-+
                  '-1
                  (binary-*
                   ((binary-* '1
                              (unary-/ (binary-* '1 '1))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((binary-+
                          (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                          (unary-- (binary-* '1 (unary-/ '1))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        (expt ((binary-* '1 (unary-/ '2)))
                              (unary-- |var0|))
                        (binary-+
                         '-1
                         (binary-*
                          ((binary-* '1
                                     (unary-/ (binary-* '1 '1))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((binary-+
                                 (binary-*
                                  (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                  (binary-+ '1 (binary-* '1 '1)))
                                 (unary--
                                      (binary-* '1 (unary-/ '1))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        (expt ((binary-* '1 (unary-/ '2)))
                              (unary-- |var1|))
                        (binary-+
                         '-1
                         (binary-*
                          ((binary-* '1
                                     (unary-/ (binary-* '1 '1))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((binary-+
                                 (binary-*
                                  (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                  (binary-+ '1 (binary-* '1 '1)))
                                 (unary--
                                      (binary-* '1 (unary-/ '1))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (expt
                                                 ((binary-* '1 (unary-/ '2)))
                                                 (unary-- |var0|))
Error(formula): This is not a valid operator: ((binary-*
                                                 '1
                                                 (unary-/ (binary-* '1 '1))))
Error(formula): This is not a valid operator: ((binary-+
                                                (binary-*
                                                 (binary-*
                                                  '1
                                                  (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                 (binary-+ '1
                                                           (binary-* '1 '1)))
                                                (unary--
                                                   (binary-* '1
                                                             (unary-/ '1)))))
Error(formula): This is not a valid operator: (expt
                                                 ((binary-* '1 (unary-/ '2)))
                                                 (unary-- |var1|))
Error(formula): This is not a valid operator: ((binary-*
                                                 '1
                                                 (unary-/ (binary-* '1 '1))))
Error(formula): This is not a valid operator: ((binary-+
                                                (binary-*
                                                 (binary-*
                                                  '1
                                                  (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                 (binary-+ '1
                                                           (binary-* '1 '1)))
                                                (unary--
                                                   (binary-* '1
                                                             (unary-/ '1)))))
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)
  File "z3_files/B-term-neg.py", line 9, in <lambda>
    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)
  File "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py", line 47, in plus
    return reduce(lambda x, y: x+y, args)
  File "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py", line 47, in <lambda>
    return reduce(lambda x, y: x+y, args)
  File "src/api/python/z3.py", line 1848, in __add__
  File "src/api/python/z3.py", line 870, in _coerce_exprs
  File "src/api/python/z3.py", line 1781, in cast
  File "src/api/python/z3.py", line 2564, in RealVal
  File "src/api/python/z3core.py", line 1852, in Z3_mk_numeral
z3types.Z3Exception: 'parser error'
; Z3: `python z3_files/B-term-neg.py`: 0.13 sec, 8,272 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)"
             "  File \"z3_files/B-term-neg.py\", line 9, in <lambda>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)"
             "  File \"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py\", line 47, in plus"
             "    return reduce(lambda x, y: x+y, args)"
             "  File \"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py\", line 47, in <lambda>"
             "    return reduce(lambda x, y: x+y, args)"
             "  File \"src/api/python/z3.py\", line 1848, in __add__"
             "  File \"src/api/python/z3.py\", line 870, in _coerce_exprs"
             "  File \"src/api/python/z3.py\", line 1781, in cast"
             "  File \"src/api/python/z3.py\", line 2564, in RealVal"
             "  File \"src/api/python/z3core.py\", line 1852, in Z3_mk_numeral"
             "z3types.Z3Exception: 'parser error'")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.00, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:04:39 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


***********************************************
************ ABORTING from raw Lisp ***********
Error:  Unexpected end of file on #<BASIC-FILE-CHARACTER-INPUT-STREAM ("/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp"/8 ISO-8859-1) #x302002B4791D>, near position 10372
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:05:48 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.53 seconds (prove: 0.00, print: 0.00, other: 4.53)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
res2: (binary-* '1 (unary-/ '2)),
res3: nil
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
res2: (binary-* '1
                (unary-/ (binary-* '1 '1))),
res3: nil
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
res2: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1)))),
res3: nil

***********************************************
Note:  The value NIL is not of the expected type REAL.
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(cons '(1 2 3) nil)
((1 2 3))
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:07:02 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.48 seconds (prove: 0.00, print: 0.00, other: 4.48)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))

***********************************************
Note:  The value NIL is not of the expected type REAL.
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[01:43:51 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "test-all.lisp")


ACL2 Error in LD:  "test-all.lisp" is an illegal value for the state
global variable STANDARD-OI.  See :DOC STANDARD-OI.  It is likely that
the file you requested, 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/test-all.lisp", does not
exist.

ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[01:44:22 yanpeng] DPLL $ ls
#DPLL_functions.lisp#  DPLL-theorems.lisp  expanded  global.lisp     z3_files
DPLL-functions.lisp    DPLL-todo           foo.lisp  summation.lisp

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[01:44:23 yanpeng] DPLL $ cd ..

[~/project/ACL2] [ 5 files 28Kb ]
[01:44:25 yanpeng] ACL2(branch:ACL22Z3) $ ls
clause-processor-test  DPLL  README  smtlink  test_bitBucket

[~/project/ACL2] [ 5 files 28Kb ]
[01:44:26 yanpeng] ACL2(branch:ACL22Z3) $ cd smtlink

[~/project/ACL2/smtlink] [ 19 files 136Kb ]
[01:44:27 yanpeng] smtlink $ ls
ACL2-related-questions  SMT-connect.lisp    SMT-interpreter.lisp  test.lisp
config.lisp             SMT-extract.lisp    SMT-run.lisp          todo
expanded                #SMT-formula.lisp#  SMT-translator.lisp   z3_files
helper.lisp             SMT-formula.lisp    SMT-z3.lisp           z3_interface
old                     SMT-function.lisp   test-all.lisp

[~/project/ACL2/smtlink] [ 19 files 136Kb ]
[01:44:28 yanpeng] smtlink $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "test-all.lisp")

ACL2 Version 6.4.  Level 2.  Cbd 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-connect" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "./SMT-connect" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "./SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.56 seconds (prove: 0.00, print: 0.00, other: 4.56)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Summary
Form:  ( defconst *a* ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 *a*
ACL2 !>>
Since bar0 is non-recursive, its admission is trivial.  We observe
that the type of bar0 is described by the theorem (acl2-numberp (bar0 x)).
We used primitive type reasoning.

Summary
Form:  ( defun bar0 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 bar0
ACL2 !>>
ACL2 Warning [Subsume] in ( defthm test0 ...):  The previously added
rule commutativity-of-+ subsumes a newly proposed :rewrite rule generated
from test0, in the sense that the old rule rewrites a more general
target.  Because the new rule will be tried first, it may nonetheless
find application.

Original clause(connect): (implies (if (rationalp x) 't 'nil)
                                   (equal (binary-+ x x)
                                          (binary-* '1 (bar0 x))))
rewritten: (implies (if (rationalp x) 't 'nil)
                    (equal (binary-+ x x)
                           (binary-* '1 nil)))
Expanded(SMT-z3): (implies (if (rationalp x) 't 'nil)
                           (equal (binary-+ x x)
                                  (binary-* '1 nil)))
Final index number: nil
counterexample
[X = -1]
; Z3: `python z3_files/test0.py`: 0.20 sec, 2,096 bytes
("counterexample" "[X = -1]")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test0 ...)
Rules: ((:definition bar0)
        (:definition fix)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite unicity-of-1))
Warnings:  Subsume
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  72
 test0
ACL2 !>>
Since foo1 is non-recursive, its admission is trivial.  We observe
that the type of foo1 is described by the theorem (acl2-numberp (foo1 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun foo1 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo1
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test1 ...):  A :rewrite rule generated
from test1 will be triggered only by terms containing the non-recursive
function symbol foo1.  Unless this function is disabled, this rule
is unlikely ever to be used.

Original clause(connect): (implies
                               (if (if (rationalp x)
                                       (if (integerp y) (integerp z) 'nil)
                                       'nil)
                                   (if (not (not (< '0 x)))
                                       (if (equal z (binary-+ '3/2 '4))
                                           (if (< y x)
                                               (< y x)
                                               (< (binary-+ y '40/3) x))
                                           'nil)
                                       'nil)
                                   'nil)
                               (< (foo1 x y) (foo1 x (foo1 x z))))

***********************************************
Note:  The value NIL is not of the expected type REAL.
  Will attempt to exit the proof in progress;
  otherwise, the next interrupt will abort the proof.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
Here is the current pstack [see :DOC pstack]:
(waterfall)

*** Note: No checkpoints to print. ***
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/smtlink] [ 19 files 136Kb ]
[01:45:36 yanpeng] smtlink $ acl
If 'acl' is not a typo you can use command-not-found to lookup the package that contains it, like this:
    cnf acl

[~/project/ACL2/smtlink] [ 19 files 136Kb ]
[01:45:37 yanpeng] smtlink $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "test-all.lisp")

ACL2 Version 6.4.  Level 2.  Cbd 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-connect" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "./SMT-connect" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "./SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.52 seconds (prove: 0.00, print: 0.00, other: 4.52)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Summary
Form:  ( defconst *a* ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 *a*
ACL2 !>>
Since bar0 is non-recursive, its admission is trivial.  We observe
that the type of bar0 is described by the theorem (acl2-numberp (bar0 x)).
We used primitive type reasoning.

Summary
Form:  ( defun bar0 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 bar0
ACL2 !>>
ACL2 Warning [Subsume] in ( defthm test0 ...):  The previously added
rule commutativity-of-+ subsumes a newly proposed :rewrite rule generated
from test0, in the sense that the old rule rewrites a more general
target.  Because the new rule will be tried first, it may nonetheless
find application.

Original clause(connect): (implies (if (rationalp x) 't 'nil)
                                   (equal (binary-+ x x)
                                          (binary-* '1 (bar0 x))))
rewritten: (implies (if (rationalp x) 't 'nil)
                    (equal (binary-+ x x)
                           (binary-* '1
                                     ((lambda (|var0|) (binary-* '2 |var0|))
                                      x))))
Expanded(SMT-z3): (implies
                     (if (rationalp x) 't 'nil)
                     (equal (binary-+ x x)
                            (binary-* '1
                                      ((lambda (|var0|) (binary-* '2 |var0|))
                                       x))))
Final index number: 1
proved
; Z3: `python z3_files/test0.py`: 0.13 sec, 2,000 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (rationalp x) 't 'nil)
                              (equal
                                 (binary-+ x x)
                                 (binary-*
                                      '1
                                      ((lambda (|var0|) (binary-* '2 |var0|))
                                       x)))))
                            (implies (if (rationalp x) 't 'nil)
                                     (equal (binary-+ x x)
                                            (binary-* '1 (bar0 x))))))

 Success!
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test0 ...)
Rules: ((:definition bar0)
        (:definition not)
        (:rewrite unicity-of-1))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Subsume
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  62
 test0
ACL2 !>>
Since foo1 is non-recursive, its admission is trivial.  We observe
that the type of foo1 is described by the theorem (acl2-numberp (foo1 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun foo1 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo1
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test1 ...):  A :rewrite rule generated
from test1 will be triggered only by terms containing the non-recursive
function symbol foo1.  Unless this function is disabled, this rule
is unlikely ever to be used.

Original clause(connect): (implies
                               (if (if (rationalp x)
                                       (if (integerp y) (integerp z) 'nil)
                                       'nil)
                                   (if (not (not (< '0 x)))
                                       (if (equal z (binary-+ '3/2 '4))
                                           (if (< y x)
                                               (< y x)
                                               (< (binary-+ y '40/3) x))
                                           'nil)
                                       'nil)
                                   'nil)
                               (< (foo1 x y) (foo1 x (foo1 x z))))
rewritten: (implies (if (if (rationalp x)
                            (if (integerp y) (integerp z) 'nil)
                            'nil)
                        (if (not (not (< '0 x)))
                            (if (equal z (binary-+ '3/2 '4))
                                (if (< y x)
                                    (< y x)
                                    (< (binary-+ y '40/3) x))
                                'nil)
                            'nil)
                        'nil)
                    (< ((lambda (|var0| |var1|)
                                (binary-* |var0| (binary-+ '1 |var1|)))
                        x y)
                       ((lambda (|var2| |var3|)
                                (binary-* |var2| (binary-+ '1 |var3|)))
                        x
                        ((lambda (|var4| |var5|)
                                 (binary-* |var4| (binary-+ '1 |var5|)))
                         x z))))
Expanded(SMT-z3): (implies
                       (if (if (rationalp x)
                               (if (integerp y) (integerp z) 'nil)
                               'nil)
                           (if (not (not (< '0 x)))
                               (if (equal z (binary-+ '3/2 '4))
                                   (if (< y x)
                                       (< y x)
                                       (< (binary-+ y '40/3) x))
                                   'nil)
                               'nil)
                           'nil)
                       (< ((lambda (|var0| |var1|)
                                   (binary-* |var0| (binary-+ '1 |var1|)))
                           x y)
                          ((lambda (|var2| |var3|)
                                   (binary-* |var2| (binary-+ '1 |var3|)))
                           x
                           ((lambda (|var4| |var5|)
                                    (binary-* |var4| (binary-+ '1 |var5|)))
                            x z))))
Final index number: 6
proved
; Z3: `python z3_files/test1.py`: 0.16 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (if (rationalp x)
                                      (if (integerp y) (integerp z) 'nil)
                                      'nil)
                                  (if (not (not (< '0 x)))
                                      (if (equal z (binary-+ '3/2 '4))
                                          (if (< y x)
                                              (< y x)
                                              (< (binary-+ y '40/3) x))
                                          'nil)
                                      'nil)
                                  'nil)
                              (<
                               ((lambda
                                     (|var0| |var1|)
                                     (binary-* |var0| (binary-+ '1 |var1|)))
                                x y)
                               ((lambda
                                     (|var2| |var3|)
                                     (binary-* |var2| (binary-+ '1 |var3|)))
                                x
                                ((lambda
                                      (|var4| |var5|)
                                      (binary-* |var4| (binary-+ '1 |var5|)))
                                 x z)))))
                            (implies
                                 (if (if (rationalp x)
                                         (if (integerp y) (integerp z) 'nil)
                                         'nil)
                                     (if (not (not (< '0 x)))
                                         (if (equal z (binary-+ '3/2 '4))
                                             (if (< y x)
                                                 (< y x)
                                                 (< (binary-+ y '40/3) x))
                                             'nil)
                                         'nil)
                                     'nil)
                                 (< (foo1 x y) (foo1 x (foo1 x z))))))

 Success!
Goal'

Q.E.D.

Summary
Form:  ( defthm test1 ...)
Rules: ((:fake-rune-for-type-set nil))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
 test1
ACL2 !>>
Since foo2 is non-recursive, its admission is trivial.  We observe
that the type of foo2 is described by the theorem (acl2-numberp (foo2 x)).
We used primitive type reasoning.

Summary
Form:  ( defun foo2 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo2
ACL2 !>>
Since bar2 is non-recursive, its admission is trivial.  We observe
that the type of bar2 is described by the theorem (acl2-numberp (bar2 y)).
We used primitive type reasoning.

Summary
Form:  ( defun bar2 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 bar2
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test2 ...):  A :rewrite rule generated
from test2 will be triggered only by terms containing the non-recursive
function symbols bar2 and foo2.  Unless these functions are disabled,
this rule is unlikely ever to be used.

Original clause(connect): (implies (if (rationalp y) (< '1 y) 'nil)
                                   (< '12 (bar2 (foo2 y))))
rewritten: (implies
                (if (rationalp y) (< '1 y) 'nil)
                (< '12
                   ((lambda (|var0|)
                            (binary-* '2
                                      ((lambda (|var1|) (binary-+ |var1| '3))
                                       |var0|)))
                    ((lambda (|var2|) (binary-+ |var2| '3))
                     y))))
Expanded(SMT-z3): (implies
                   (if (rationalp y) (< '1 y) 'nil)
                   (< '12
                      ((lambda
                            (|var0|)
                            (binary-* '2
                                      ((lambda (|var1|) (binary-+ |var1| '3))
                                       |var0|)))
                       ((lambda (|var2|) (binary-+ |var2| '3))
                        y))))
Final index number: 3
proved
; Z3: `python z3_files/test2.py`: 0.10 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (rationalp y) (< '1 y) 'nil)
                              (<
                               '12
                               ((lambda
                                 (|var0|)
                                 (binary-*
                                      '2
                                      ((lambda (|var1|) (binary-+ |var1| '3))
                                       |var0|)))
                                ((lambda (|var2|) (binary-+ |var2| '3))
                                 y)))))
                            (implies (if (rationalp y) (< '1 y) 'nil)
                                     (< '12 (bar2 (foo2 y))))))

 Success!
Goal'

Q.E.D.

Summary
Form:  ( defthm test2 ...)
Rules: ((:definition bar2)
        (:definition foo2)
        (:definition not)
        (:executable-counterpart binary-+)
        (:executable-counterpart tau-system)
        (:rewrite associativity-of-+))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  81
 test2
ACL2 !>>
Since foo3 is non-recursive, its admission is trivial.  We observe
that the type of foo3 is described by the theorem 
(acl2-numberp (foo3 x args)).  We used primitive type reasoning.

Summary
Form:  ( defun foo3 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo3
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test3 ...):  A :rewrite rule generated
from test3 will be triggered only by terms containing the non-recursive
function symbol foo3.  Unless this function is disabled, this rule
is unlikely ever to be used.


ACL2 Warning [Free] in ( defthm test3 ...):  A :rewrite rule generated
from test3 contains the free variables i and j.  These variables will
be chosen by searching for instances of (integerp i) and (integerp j)
in the context of the term being rewritten.  This is generally a severe
restriction on the applicability of a :rewrite rule.  See :DOC free-
variables.

Original clause(connect): (implies
                               (if (if (rationalp x)
                                       (if (integerp i) (integerp j) 'nil)
                                       'nil)
                                   (if (< '0 x)
                                       (if (< '0 i) (< '0 j) 'nil)
                                       'nil)
                                   'nil)
                               (< '0 (foo3 x '(i j))))
rewritten: (implies (if (if (rationalp x)
                            (if (integerp i) (integerp j) 'nil)
                            'nil)
                        (if (< '0 x)
                            (if (< '0 i) (< '0 j) 'nil)
                            'nil)
                        'nil)
                    (< '0
                       ((lambda (|var0| |var1|)
                                (binary-+ |var0|
                                          (binary-+ (nth '0 |var1|)
                                                    (nth '1 |var1|))))
                        x '(i j))))
Expanded(SMT-z3): (implies (if (if (rationalp x)
                                   (if (integerp i) (integerp j) 'nil)
                                   'nil)
                               (if (< '0 x)
                                   (if (< '0 i) (< '0 j) 'nil)
                                   'nil)
                               'nil)
                           (< '0
                              ((lambda (|var0| |var1|)
                                       (binary-+ |var0|
                                                 (binary-+ (nth '0 |var1|)
                                                           (nth '1 |var1|))))
                               x '(i j))))
Final index number: 2
proved
; Z3: `python z3_files/test3.py`: 0.12 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (if (rationalp x)
                                      (if (integerp i) (integerp j) 'nil)
                                      'nil)
                                  (if (< '0 x)
                                      (if (< '0 i) (< '0 j) 'nil)
                                      'nil)
                                  'nil)
                              (< '0
                                 ((lambda
                                       (|var0| |var1|)
                                       (binary-+ |var0|
                                                 (binary-+ (nth '0 |var1|)
                                                           (nth '1 |var1|))))
                                  x '(i j)))))
                            (implies
                                 (if (if (rationalp x)
                                         (if (integerp i) (integerp j) 'nil)
                                         'nil)
                                     (if (< '0 x)
                                         (if (< '0 i) (< '0 j) 'nil)
                                         'nil)
                                     'nil)
                                 (< '0 (foo3 x '(i j))))))

 Success!
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test3 ...)
Rules: ((:definition fix)
        (:definition foo3)
        (:definition not)
        (:executable-counterpart binary-+)
        (:executable-counterpart nth)
        (:rewrite commutativity-of-+)
        (:rewrite unicity-of-0))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Free and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  360
 test3
ACL2 !>>
Since a4 is non-recursive, its admission is trivial.  We observe that
the type of a4 is described by the theorem (acl2-numberp (a4 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun a4 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 a4
ACL2 !>>
Since b4 is non-recursive, its admission is trivial.  We observe that
the type of b4 is described by the theorem (acl2-numberp (b4 x)). 
We used the :type-prescription rule a4.

Summary
Form:  ( defun b4 ...)
Rules: ((:type-prescription a4))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b4
ACL2 !>>
Since c4 is non-recursive, its admission is trivial.  We observe that
the type of c4 is described by the theorem (acl2-numberp (c4 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun c4 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 c4
ACL2 !>>
Since d4 is non-recursive, its admission is trivial.  We observe that
the type of d4 is described by the theorem (acl2-numberp (d4 x)). 
We used the :type-prescription rule a4.

Summary
Form:  ( defun d4 ...)
Rules: ((:type-prescription a4))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 d4
ACL2 !>>
Since e4 is non-recursive, its admission is trivial.  We observe that
the type of e4 is described by the theorem (acl2-numberp (e4 x)). 

Summary
Form:  ( defun e4 ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 e4
ACL2 !>>
Since f4 is non-recursive, its admission is trivial.  We observe that
the type of f4 is described by the theorem (acl2-numberp (f4 x y)).
We used the :type-prescription rule c4.

Summary
Form:  ( defun f4 ...)
Rules: ((:type-prescription c4))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 f4
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test4 ...):  A :rewrite rule generated
from test4 will be triggered only by terms containing the non-recursive
function symbols f4, d4, c4, a4 and b4.  Unless these functions are
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (if (rationalp a) (rationalp b) 'nil)
                                       't
                                       'nil)
                                   (not (< (f4 (d4 (c4 a b)) (a4 (b4 a) b))
                                           (a4 (b4 a) b))))
rewritten: (implies (if (if (rationalp a) (rationalp b) 'nil)
                        't
                        'nil)
                    (not (< ((lambda (|var0| |var1|)
                                     ((lambda (|var2| |var3|)
                                              (binary-+ |var2| |var3|))
                                      |var0|
                                      ((lambda (|var4|) (unary-- |var4|))
                                       |var1|)))
                             ((lambda (|var5|)
                                      ((lambda (|var6| |var7|)
                                               (binary-* |var6| |var7|))
                                       |var5| |var5|))
                              ((lambda (|var8| |var9|)
                                       (binary-+ |var8| |var9|))
                               a b))
                             ((lambda (|var10| |var11|)
                                      (binary-* |var10| |var11|))
                              ((lambda (|var12|)
                                       ((lambda (|var13| |var14|)
                                                (binary-* |var13| |var14|))
                                        '2
                                        |var12|))
                               a)
                              b))
                            ((lambda (|var15| |var16|)
                                     (binary-* |var15| |var16|))
                             ((lambda (|var17|)
                                      ((lambda (|var18| |var19|)
                                               (binary-* |var18| |var19|))
                                       '2
                                       |var17|))
                              a)
                             b))))
Expanded(SMT-z3): (implies
                      (if (if (rationalp a) (rationalp b) 'nil)
                          't
                          'nil)
                      (not (< ((lambda (|var0| |var1|)
                                       ((lambda (|var2| |var3|)
                                                (binary-+ |var2| |var3|))
                                        |var0|
                                        ((lambda (|var4|) (unary-- |var4|))
                                         |var1|)))
                               ((lambda (|var5|)
                                        ((lambda (|var6| |var7|)
                                                 (binary-* |var6| |var7|))
                                         |var5| |var5|))
                                ((lambda (|var8| |var9|)
                                         (binary-+ |var8| |var9|))
                                 a b))
                               ((lambda (|var10| |var11|)
                                        (binary-* |var10| |var11|))
                                ((lambda (|var12|)
                                         ((lambda (|var13| |var14|)
                                                  (binary-* |var13| |var14|))
                                          '2
                                          |var12|))
                                 a)
                                b))
                              ((lambda (|var15| |var16|)
                                       (binary-* |var15| |var16|))
                               ((lambda (|var17|)
                                        ((lambda (|var18| |var19|)
                                                 (binary-* |var18| |var19|))
                                         '2
                                         |var17|))
                                a)
                               b))))
Final index number: 20
proved
; Z3: `python z3_files/test4.py`: 0.33 sec, 1,808 bytes
Expanded clause(connect): (((not
                             (implies
                              (if (if (rationalp a) (rationalp b) 'nil)
                                  't
                                  'nil)
                              (not
                               (<
                                ((lambda (|var0| |var1|)
                                         ((lambda (|var2| |var3|)
                                                  (binary-+ |var2| |var3|))
                                          |var0|
                                          ((lambda (|var4|) (unary-- |var4|))
                                           |var1|)))
                                 ((lambda (|var5|)
                                          ((lambda (|var6| |var7|)
                                                   (binary-* |var6| |var7|))
                                           |var5| |var5|))
                                  ((lambda (|var8| |var9|)
                                           (binary-+ |var8| |var9|))
                                   a b))
                                 ((lambda (|var10| |var11|)
                                          (binary-* |var10| |var11|))
                                  ((lambda
                                        (|var12|)
                                        ((lambda (|var13| |var14|)
                                                 (binary-* |var13| |var14|))
                                         '2
                                         |var12|))
                                   a)
                                  b))
                                ((lambda (|var15| |var16|)
                                         (binary-* |var15| |var16|))
                                 ((lambda
                                       (|var17|)
                                       ((lambda (|var18| |var19|)
                                                (binary-* |var18| |var19|))
                                        '2
                                        |var17|))
                                  a)
                                 b)))))
                            (implies
                                 (if (if (rationalp a) (rationalp b) 'nil)
                                     't
                                     'nil)
                                 (not (< (f4 (d4 (c4 a b)) (a4 (b4 a) b))
                                         (a4 (b4 a) b))))))

 Success!
Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm test4 ...)
Rules: ((:definition a4)
        (:definition b4)
        (:definition c4)
        (:definition d4)
        (:definition e4)
        (:definition f4)
        (:definition not)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  527
 test4
ACL2 !>>
Since a6 is non-recursive, its admission is trivial.  We observe that
the type of a6 is described by the theorem (acl2-numberp (a6 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun a6 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 a6
ACL2 !>>
Since b6 is non-recursive, its admission is trivial.  We observe that
the type of b6 is described by the theorem (acl2-numberp (b6 x)). 
We used the :type-prescription rule a6.

Summary
Form:  ( defun b6 ...)
Rules: ((:type-prescription a6))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b6
ACL2 !>>
Since c6 is non-recursive, its admission is trivial.  We observe that
the type of c6 is described by the theorem (acl2-numberp (c6 x y)).
We used primitive type reasoning.

Summary
Form:  ( defun c6 ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 c6
ACL2 !>>
Since d6 is non-recursive, its admission is trivial.  We observe that
the type of d6 is described by the theorem (acl2-numberp (d6 x)). 
We used the :type-prescription rule a6.

Summary
Form:  ( defun d6 ...)
Rules: ((:type-prescription a6))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 d6
ACL2 !>>
Since e6 is non-recursive, its admission is trivial.  We observe that
the type of e6 is described by the theorem (acl2-numberp (e6 x)). 

Summary
Form:  ( defun e6 ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 e6
ACL2 !>>
Since f6 is non-recursive, its admission is trivial.  We observe that
the type of f6 is described by the theorem (acl2-numberp (f6 x y)).
We used the :type-prescription rule c6.

Summary
Form:  ( defun f6 ...)
Rules: ((:type-prescription c6))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 f6
ACL2 !>>
Since foo6 is non-recursive, its admission is trivial.  We observe
that the type of foo6 is described by the theorem (acl2-numberp (foo6 x n)).
We used the :type-prescription rule expt.

Summary
Form:  ( defun foo6 ...)
Rules: ((:type-prescription expt))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 foo6
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm test6 ...):  A :rewrite rule generated
from test6 will be triggered only by terms containing the non-recursive
function symbols f6, d6, c6, foo6, a6 and b6.  Unless these functions
are disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies
                           (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (< '0 gamma)
                                  (if (< gamma '1)
                                      (if (< '0 m) (< m n) 'nil)
                                      'nil)
                                  'nil)
                              'nil)
                           (not (< (a6 (expt gamma m)
                                       (f6 (d6 (c6 a b)) (a6 (b6 a) b)))
                                   (a6 (foo6 gamma n) (a6 (b6 a) b)))))
rewritten: (implies
                (if (if (rationalp expt_gamma_n)
                        (if (rationalp expt_gamma_m)
                            (if (rationalp a)
                                (if (rationalp b)
                                    (if (rationalp gamma)
                                        (if (integerp m) (integerp n) 'nil)
                                        'nil)
                                    'nil)
                                'nil)
                            'nil)
                        'nil)
                    (if (< '0 expt_gamma_n)
                        (if (< '0 expt_gamma_m)
                            (if (< expt_gamma_n expt_gamma_m)
                                (if (< '0 gamma)
                                    (if (< gamma '1)
                                        (if (< '0 m) (< m n) 'nil)
                                        'nil)
                                    'nil)
                                'nil)
                            'nil)
                        'nil)
                    'nil)
                (not (< ((lambda (|var0| |var1|)
                                 (binary-* |var0| |var1|))
                         expt_gamma_m
                         ((lambda (|var2| |var3|)
                                  ((lambda (|var4| |var5|)
                                           (binary-+ |var4| |var5|))
                                   |var2|
                                   ((lambda (|var6|) (unary-- |var6|))
                                    |var3|)))
                          ((lambda (|var7|)
                                   ((lambda (|var8| |var9|)
                                            (binary-* |var8| |var9|))
                                    |var7| |var7|))
                           ((lambda (|var10| |var11|)
                                    (binary-+ |var10| |var11|))
                            a b))
                          ((lambda (|var12| |var13|)
                                   (binary-* |var12| |var13|))
                           ((lambda (|var14|)
                                    ((lambda (|var15| |var16|)
                                             (binary-* |var15| |var16|))
                                     '2
                                     |var14|))
                            a)
                           b)))
                        ((lambda (|var17| |var18|)
                                 (binary-* |var17| |var18|))
                         expt_gamma_n
                         ((lambda (|var21| |var22|)
                                  (binary-* |var21| |var22|))
                          ((lambda (|var23|)
                                   ((lambda (|var24| |var25|)
                                            (binary-* |var24| |var25|))
                                    '2
                                    |var23|))
                           a)
                          b)))))
Expanded(SMT-z3): (implies
                   (if
                      (if (rationalp expt_gamma_n)
                          (if (rationalp expt_gamma_m)
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                          'nil)
                      (if (< '0 expt_gamma_n)
                          (if (< '0 expt_gamma_m)
                              (if (< expt_gamma_n expt_gamma_m)
                                  (if (< '0 gamma)
                                      (if (< gamma '1)
                                          (if (< '0 m) (< m n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                          'nil)
                      'nil)
                   (not (< ((lambda (|var0| |var1|)
                                    (binary-* |var0| |var1|))
                            expt_gamma_m
                            ((lambda (|var2| |var3|)
                                     ((lambda (|var4| |var5|)
                                              (binary-+ |var4| |var5|))
                                      |var2|
                                      ((lambda (|var6|) (unary-- |var6|))
                                       |var3|)))
                             ((lambda (|var7|)
                                      ((lambda (|var8| |var9|)
                                               (binary-* |var8| |var9|))
                                       |var7| |var7|))
                              ((lambda (|var10| |var11|)
                                       (binary-+ |var10| |var11|))
                               a b))
                             ((lambda (|var12| |var13|)
                                      (binary-* |var12| |var13|))
                              ((lambda (|var14|)
                                       ((lambda (|var15| |var16|)
                                                (binary-* |var15| |var16|))
                                        '2
                                        |var14|))
                               a)
                              b)))
                           ((lambda (|var17| |var18|)
                                    (binary-* |var17| |var18|))
                            expt_gamma_n
                            ((lambda (|var21| |var22|)
                                     (binary-* |var21| |var22|))
                             ((lambda (|var23|)
                                      ((lambda (|var24| |var25|)
                                               (binary-* |var24| |var25|))
                                       '2
                                       |var23|))
                              a)
                             b)))))
Final index number: 26
proved
; Z3: `python z3_files/test6.py`: 0.13 sec, 1,808 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_m expt_gamma_n a b gamma m n)
                               (implies
                                (if
                                 (if
                                  (rationalp expt_gamma_n)
                                  (if
                                   (rationalp expt_gamma_m)
                                   (if
                                    (rationalp a)
                                    (if
                                      (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                    'nil)
                                   'nil)
                                  'nil)
                                 (if
                                   (< '0 expt_gamma_n)
                                   (if (< '0 expt_gamma_m)
                                       (if (< expt_gamma_n expt_gamma_m)
                                           (if (< '0 gamma)
                                               (if (< gamma '1)
                                                   (if (< '0 m) (< m n) 'nil)
                                                   'nil)
                                               'nil)
                                           'nil)
                                       'nil)
                                   'nil)
                                 'nil)
                                (not
                                 (<
                                  ((lambda (|var0| |var1|)
                                           (binary-* |var0| |var1|))
                                   expt_gamma_m
                                   ((lambda
                                         (|var2| |var3|)
                                         ((lambda (|var4| |var5|)
                                                  (binary-+ |var4| |var5|))
                                          |var2|
                                          ((lambda (|var6|) (unary-- |var6|))
                                           |var3|)))
                                    ((lambda
                                          (|var7|)
                                          ((lambda (|var8| |var9|)
                                                   (binary-* |var8| |var9|))
                                           |var7| |var7|))
                                     ((lambda (|var10| |var11|)
                                              (binary-+ |var10| |var11|))
                                      a b))
                                    ((lambda (|var12| |var13|)
                                             (binary-* |var12| |var13|))
                                     ((lambda
                                         (|var14|)
                                         ((lambda (|var15| |var16|)
                                                  (binary-* |var15| |var16|))
                                          '2
                                          |var14|))
                                      a)
                                     b)))
                                  ((lambda (|var17| |var18|)
                                           (binary-* |var17| |var18|))
                                   expt_gamma_n
                                   ((lambda (|var21| |var22|)
                                            (binary-* |var21| |var22|))
                                    ((lambda
                                         (|var23|)
                                         ((lambda (|var24| |var25|)
                                                  (binary-* |var24| |var25|))
                                          '2
                                          |var23|))
                                     a)
                                    b))))))
                              (expt gamma m)
                              (expt gamma n)
                              a b gamma m n))
                            (implies
                             (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (< '0 gamma)
                                  (if (< gamma '1)
                                      (if (< '0 m) (< m n) 'nil)
                                      'nil)
                                  'nil)
                              'nil)
                             (not (< (a6 (expt gamma m)
                                         (f6 (d6 (c6 a b)) (a6 (b6 a) b)))
                                     (a6 (foo6 gamma n) (a6 (b6 a) b))))))
                           ((implies
                             (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (equal expt_gamma_m (expt gamma m))
                                  (if (< '0 gamma)
                                      (if (< gamma '1)
                                          (if (< '0 m) (< m n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                             (rationalp expt_gamma_m))
                            (implies
                             (if
                              (if (rationalp a)
                                  (if (rationalp b)
                                      (if (rationalp gamma)
                                          (if (integerp m) (integerp n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              (if (equal expt_gamma_n (expt gamma n))
                                  (if (< '0 gamma)
                                      (if (< gamma '1)
                                          (if (< '0 m) (< m n) 'nil)
                                          'nil)
                                      'nil)
                                  'nil)
                              'nil)
                             (rationalp expt_gamma_n))))

 Success!
Subgoal 2
Subgoal 2'
Subgoal 1

Q.E.D.

Summary
Form:  ( defthm test6 ...)
Rules: ((:definition a6)
        (:definition b6)
        (:definition c6)
        (:definition d6)
        (:definition e6)
        (:definition f6)
        (:definition foo6)
        (:definition not)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-is-decreasing-for-pos-base<1)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1324
 test6
ACL2 !>>Bye.
 :eof
ACL2 !>(good-bye)


[~/project/ACL2/smtlink] [ 19 files 136Kb ]
[01:46:25 yanpeng] smtlink $ ls
ACL2-related-questions  SMT-connect.lisp    SMT-interpreter.lisp  test.lisp
config.lisp             SMT-extract.lisp    SMT-run.lisp          todo
expanded                #SMT-formula.lisp#  SMT-translator.lisp   z3_files
helper.lisp             SMT-formula.lisp    SMT-z3.lisp           z3_interface
old                     SMT-function.lisp   test-all.lisp

[~/project/ACL2/smtlink] [ 19 files 136Kb ]
[01:46:26 yanpeng] smtlink $ cd ..

[~/project/ACL2] [ 5 files 28Kb ]
[01:46:28 yanpeng] ACL2(branch:ACL22Z3) $ ls
clause-processor-test  DPLL  README  smtlink  test_bitBucket

[~/project/ACL2] [ 5 files 28Kb ]
[01:46:28 yanpeng] ACL2(branch:ACL22Z3) $ cd DPLL

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[01:46:30 yanpeng] DPLL $ ls
#DPLL_functions.lisp#  DPLL-theorems.lisp  expanded  global.lisp     z3_files
DPLL-functions.lisp    DPLL-todo           foo.lisp  summation.lisp

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[01:46:30 yanpeng] DPLL $ cat DPLL-todo
May 22.
1. matching inner representation in let expression. really hard. need to see it.
2. (termp ((lambda nil (binary-+ 1 1))) (w state))
   this is not a term!!!!
   For this problem, I can translate that function to its body instead of a lambda!
[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[01:46:38 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.43 seconds (prove: 0.00, print: 0.00, other: 4.43)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 (expt ((binary-* '1 (unary-/ '2)))
                       (unary-- |var0|))
                 (binary-+
                  '-1
                  (binary-*
                   ((binary-* '1
                              (unary-/ (binary-* '1 '1))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        ((binary-+
                          (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                          (unary-- (binary-* '1 (unary-/ '1))))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 (expt ((binary-* '1 (unary-/ '2)))
                       (unary-- |var1|))
                 (binary-+
                  '-1
                  (binary-*
                   ((binary-* '1
                              (unary-/ (binary-* '1 '1))))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        ((binary-+
                          (binary-*
                               (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                               (binary-+ '1 (binary-* '1 '1)))
                          (unary-- (binary-* '1 (unary-/ '1))))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        (expt ((binary-* '1 (unary-/ '2)))
                              (unary-- |var0|))
                        (binary-+
                         '-1
                         (binary-*
                          ((binary-* '1
                                     (unary-/ (binary-* '1 '1))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               ((binary-+
                                 (binary-*
                                  (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                  (binary-+ '1 (binary-* '1 '1)))
                                 (unary--
                                      (binary-* '1 (unary-/ '1))))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        (expt ((binary-* '1 (unary-/ '2)))
                              (unary-- |var1|))
                        (binary-+
                         '-1
                         (binary-*
                          ((binary-* '1
                                     (unary-/ (binary-* '1 '1))))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               ((binary-+
                                 (binary-*
                                  (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                  (binary-+ '1 (binary-* '1 '1)))
                                 (unary--
                                      (binary-* '1 (unary-/ '1))))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (expt
                                                 ((binary-* '1 (unary-/ '2)))
                                                 (unary-- |var0|))
Error(formula): This is not a valid operator: ((binary-*
                                                 '1
                                                 (unary-/ (binary-* '1 '1))))
Error(formula): This is not a valid operator: ((binary-+
                                                (binary-*
                                                 (binary-*
                                                  '1
                                                  (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                 (binary-+ '1
                                                           (binary-* '1 '1)))
                                                (unary--
                                                   (binary-* '1
                                                             (unary-/ '1)))))
Error(formula): This is not a valid operator: (expt
                                                 ((binary-* '1 (unary-/ '2)))
                                                 (unary-- |var1|))
Error(formula): This is not a valid operator: ((binary-*
                                                 '1
                                                 (unary-/ (binary-* '1 '1))))
Error(formula): This is not a valid operator: ((binary-+
                                                (binary-*
                                                 (binary-*
                                                  '1
                                                  (unary-/
                                                     (binary-*
                                                          '1
                                                          (binary-* '1 '1))))
                                                 (binary-+ '1
                                                           (binary-* '1 '1)))
                                                (unary--
                                                   (binary-* '1
                                                             (unary-/ '1)))))
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)
  File "z3_files/B-term-neg.py", line 9, in <lambda>
    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)
  File "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py", line 47, in plus
    return reduce(lambda x, y: x+y, args)
  File "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py", line 47, in <lambda>
    return reduce(lambda x, y: x+y, args)
  File "src/api/python/z3.py", line 1848, in __add__
  File "src/api/python/z3.py", line 870, in _coerce_exprs
  File "src/api/python/z3.py", line 1781, in cast
  File "src/api/python/z3.py", line 2564, in RealVal
  File "src/api/python/z3core.py", line 1852, in Z3_mk_numeral
z3types.Z3Exception: 'parser error'
; Z3: `python z3_files/B-term-neg.py`: 0.20 sec, 8,272 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)"
             "  File \"z3_files/B-term-neg.py\", line 9, in <lambda>"
             "    conclusion=s.lt(s.plus((lambda var0:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),False)))))))))(H),(lambda var1:s.times(False,s.plus(-1,s.times(False,s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),False)))))))))(s.negate(H))),0)"
             "  File \"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py\", line 47, in plus"
             "    return reduce(lambda x, y: x+y, args)"
             "  File \"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py\", line 47, in <lambda>"
             "    return reduce(lambda x, y: x+y, args)"
             "  File \"src/api/python/z3.py\", line 1848, in __add__"
             "  File \"src/api/python/z3.py\", line 870, in _coerce_exprs"
             "  File \"src/api/python/z3.py\", line 1781, in cast"
             "  File \"src/api/python/z3.py\", line 2564, in RealVal"
             "  File \"src/api/python/z3core.py\", line 1852, in Z3_mk_numeral"
             "z3types.Z3Exception: 'parser error'")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye
)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[02:15:00 yanpeng] DPLL $ ???
If '???' is not a typo you can use command-not-found to lookup the package that contains it, like this:
    cnf ???

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[02:15:02 yanpeng] DPLL acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.43 seconds (prove: 0.00, print: 0.00, other: 4.43)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (lambda
               (|var0|)
               (binary-*
                (expt (binary-* '1 (unary-/ '2))
                      (unary-- |var0|))
                (binary-+
                 '-1
                 (binary-*
                  (binary-* '1 (unary-/ (binary-* '1 '1)))
                  (binary-*
                   (binary-+ '1 (binary-* '1 '1))
                   (unary-/
                    (binary-+
                     '1
                     (binary-*
                      '1
                      (binary-+
                       (binary-* |var0| '1/3200)
                       (binary-+
                        (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                        (unary-- (binary-* '1 (unary-/ '1)))))))))))))
              (lambda
               (|var1|)
               (binary-*
                (expt (binary-* '1 (unary-/ '2))
                      (unary-- |var1|))
                (binary-+
                 '-1
                 (binary-*
                  (binary-* '1 (unary-/ (binary-* '1 '1)))
                  (binary-*
                   (binary-+ '1 (binary-* '1 '1))
                   (unary-/
                    (binary-+
                     '1
                     (binary-*
                      '1
                      (binary-+
                       (binary-* |var1| '1/3200)
                       (binary-+
                        (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                        (unary-- (binary-* '1 (unary-/ '1))))))))))))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (lambda
                      (|var0|)
                      (binary-*
                       (expt (binary-* '1 (unary-/ '2))
                             (unary-- |var0|))
                       (binary-+
                        '-1
                        (binary-*
                         (binary-* '1 (unary-/ (binary-* '1 '1)))
                         (binary-*
                          (binary-+ '1 (binary-* '1 '1))
                          (unary-/
                           (binary-+
                            '1
                            (binary-*
                             '1
                             (binary-+
                              (binary-* |var0| '1/3200)
                              (binary-+
                               (binary-*
                                (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                (binary-+ '1 (binary-* '1 '1)))
                               (unary-- (binary-* '1 (unary-/ '1)))))))))))))
                     (lambda
                      (|var1|)
                      (binary-*
                       (expt (binary-* '1 (unary-/ '2))
                             (unary-- |var1|))
                       (binary-+
                        '-1
                        (binary-*
                         (binary-* '1 (unary-/ (binary-* '1 '1)))
                         (binary-*
                          (binary-+ '1 (binary-* '1 '1))
                          (unary-/
                           (binary-+
                            '1
                            (binary-*
                             '1
                             (binary-+
                              (binary-* |var1| '1/3200)
                              (binary-+
                               (binary-*
                                (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                (binary-+ '1 (binary-* '1 '1)))
                               (unary--
                                    (binary-* '1 (unary-/ '1))))))))))))))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (|var0|)
Error(formula): This is not a valid operator: (expt
                                                   (binary-* '1 (unary-/ '2))
                                                   (unary-- |var0|))
Error(formula): This is not a valid operator: (|var1|)
Error(formula): This is not a valid operator: (expt
                                                   (binary-* '1 (unary-/ '2))
                                                   (unary-- |var1|))
  File "z3_files/B-term-neg.py", line 9
    conclusion=s.lt(s.plus(lambda(False,s.times(False,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1))))))))))))),lambda(False,s.times(False,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))))))))))),0)
                                         ^
SyntaxError: invalid syntax
; Z3: `python z3_files/B-term-neg.py`: 0.06 sec, 5,152 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 9"
             "    conclusion=s.lt(s.plus(lambda(False,s.times(False,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1))))))))))))),lambda(False,s.times(False,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))))))))))),0)"
             "                                         ^"
             "SyntaxError: invalid syntax")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.16, print: 0.00, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[02:20:21 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.44 seconds (prove: 0.00, print: 0.00, other: 4.44)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (lambda
               (|var0|)
               (binary-*
                (expt (binary-* '1 (unary-/ '2))
                      (unary-- |var0|))
                (binary-+
                 '-1
                 (binary-*
                  (binary-* '1 (unary-/ (binary-* '1 '1)))
                  (binary-*
                   (binary-+ '1 (binary-* '1 '1))
                   (unary-/
                    (binary-+
                     '1
                     (binary-*
                      '1
                      (binary-+
                       (binary-* |var0| '1/3200)
                       (binary-+
                        (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                        (unary-- (binary-* '1 (unary-/ '1)))))))))))))
              (lambda
               (|var1|)
               (binary-*
                expt_gamma_minus_h
                (binary-+
                 '-1
                 (binary-*
                  (binary-* '1 (unary-/ (binary-* '1 '1)))
                  (binary-*
                   (binary-+ '1 (binary-* '1 '1))
                   (unary-/
                    (binary-+
                     '1
                     (binary-*
                      '1
                      (binary-+
                       (binary-* |var1| '1/3200)
                       (binary-+
                        (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                        (unary-- (binary-* '1 (unary-/ '1))))))))))))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (lambda
                      (|var0|)
                      (binary-*
                       (expt (binary-* '1 (unary-/ '2))
                             (unary-- |var0|))
                       (binary-+
                        '-1
                        (binary-*
                         (binary-* '1 (unary-/ (binary-* '1 '1)))
                         (binary-*
                          (binary-+ '1 (binary-* '1 '1))
                          (unary-/
                           (binary-+
                            '1
                            (binary-*
                             '1
                             (binary-+
                              (binary-* |var0| '1/3200)
                              (binary-+
                               (binary-*
                                (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                (binary-+ '1 (binary-* '1 '1)))
                               (unary-- (binary-* '1 (unary-/ '1)))))))))))))
                     (lambda
                      (|var1|)
                      (binary-*
                       expt_gamma_minus_h
                       (binary-+
                        '-1
                        (binary-*
                         (binary-* '1 (unary-/ (binary-* '1 '1)))
                         (binary-*
                          (binary-+ '1 (binary-* '1 '1))
                          (unary-/
                           (binary-+
                            '1
                            (binary-*
                             '1
                             (binary-+
                              (binary-* |var1| '1/3200)
                              (binary-+
                               (binary-*
                                (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                (binary-+ '1 (binary-* '1 '1)))
                               (unary--
                                    (binary-* '1 (unary-/ '1))))))))))))))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (|var0|)
Error(formula): This is not a valid operator: (expt
                                                   (binary-* '1 (unary-/ '2))
                                                   (unary-- |var0|))
Error(formula): This is not a valid operator: (|var1|)
  File "z3_files/B-term-neg.py", line 9
    conclusion=s.lt(s.plus(lambda(False,s.times(False,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1))))))))))))),lambda(False,s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))))))))))),0)
                                         ^
SyntaxError: invalid syntax
; Z3: `python z3_files/B-term-neg.py`: 0.10 sec, 5,216 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 9"
             "    conclusion=s.lt(s.plus(lambda(False,s.times(False,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1))))))))))))),lambda(False,s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))))))))))),0)"
             "                                         ^"
             "SyntaxError: invalid syntax")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.16, print: 0.00, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[02:21:41 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.44 seconds (prove: 0.00, print: 0.00, other: 4.44)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (lambda
               (|var0|)
               (binary-*
                expt_gamma_h
                (binary-+
                 '-1
                 (binary-*
                  (binary-* '1 (unary-/ (binary-* '1 '1)))
                  (binary-*
                   (binary-+ '1 (binary-* '1 '1))
                   (unary-/
                    (binary-+
                     '1
                     (binary-*
                      '1
                      (binary-+
                       (binary-* |var0| '1/3200)
                       (binary-+
                        (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                        (unary-- (binary-* '1 (unary-/ '1)))))))))))))
              (lambda
               (|var1|)
               (binary-*
                expt_gamma_minus_h
                (binary-+
                 '-1
                 (binary-*
                  (binary-* '1 (unary-/ (binary-* '1 '1)))
                  (binary-*
                   (binary-+ '1 (binary-* '1 '1))
                   (unary-/
                    (binary-+
                     '1
                     (binary-*
                      '1
                      (binary-+
                       (binary-* |var1| '1/3200)
                       (binary-+
                        (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                        (unary-- (binary-* '1 (unary-/ '1))))))))))))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (lambda
                      (|var0|)
                      (binary-*
                       expt_gamma_h
                       (binary-+
                        '-1
                        (binary-*
                         (binary-* '1 (unary-/ (binary-* '1 '1)))
                         (binary-*
                          (binary-+ '1 (binary-* '1 '1))
                          (unary-/
                           (binary-+
                            '1
                            (binary-*
                             '1
                             (binary-+
                              (binary-* |var0| '1/3200)
                              (binary-+
                               (binary-*
                                (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                (binary-+ '1 (binary-* '1 '1)))
                               (unary-- (binary-* '1 (unary-/ '1)))))))))))))
                     (lambda
                      (|var1|)
                      (binary-*
                       expt_gamma_minus_h
                       (binary-+
                        '-1
                        (binary-*
                         (binary-* '1 (unary-/ (binary-* '1 '1)))
                         (binary-*
                          (binary-+ '1 (binary-* '1 '1))
                          (unary-/
                           (binary-+
                            '1
                            (binary-*
                             '1
                             (binary-+
                              (binary-* |var1| '1/3200)
                              (binary-+
                               (binary-*
                                (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                (binary-+ '1 (binary-* '1 '1)))
                               (unary--
                                    (binary-* '1 (unary-/ '1))))))))))))))
                    '0))
Final index number: 2
Error(formula): This is not a valid operator: (|var0|)
Error(formula): This is not a valid operator: (|var1|)
  File "z3_files/B-term-neg.py", line 9
    conclusion=s.lt(s.plus(lambda(False,s.times(EXPT_GAMMA_H,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1))))))))))))),lambda(False,s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))))))))))),0)
                                         ^
SyntaxError: invalid syntax
; Z3: `python z3_files/B-term-neg.py`: 0.04 sec, 5,232 bytes
Z3 failure: ("  File \"z3_files/B-term-neg.py\", line 9"
             "    conclusion=s.lt(s.plus(lambda(False,s.times(EXPT_GAMMA_H,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var0,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1))))))))))))),lambda(False,s.times(EXPT_GAMMA_MINUS_H,s.plus(-1,s.times(s.times(1,s.reciprocal(s.times(1,1))),s.times(s.plus(1,s.times(1,1)),s.reciprocal(s.plus(1,s.times(1,s.plus(s.times(var1,Q(1,3200)),s.plus(s.times(s.times(1,s.reciprocal(s.times(1,s.times(1,1)))),s.plus(1,s.times(1,1))),s.negate(s.times(1,s.reciprocal(1)))))))))))))),0)"
             "                                         ^"
             "SyntaxError: invalid syntax")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.14, print: 0.01, other: 0.00)
Prover steps counted:  7915

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[13:59:17 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies (if (integerp h) (< '2 h) 'nil)
                                   (< (binary-+ (b-term h)
                                                (b-term (unary-- h)))
                                      '0))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ '2))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              ((lambda
                (|var0|)
                (binary-*
                 expt_gamma_h
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1)))))))))))))
               h)
              ((lambda
                (|var1|)
                (binary-*
                 expt_gamma_minus_h
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1)))))))))))))
               (unary-- h)))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     ((lambda
                       (|var0|)
                       (binary-*
                        expt_gamma_h
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary--
                                     (binary-* '1 (unary-/ '1)))))))))))))
                      h)
                     ((lambda
                       (|var1|)
                       (binary-*
                        expt_gamma_minus_h
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary--
                                     (binary-* '1 (unary-/ '1)))))))))))))
                      (unary-- h)))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 1.02 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  ((lambda
                                    (|var0|)
                                    (binary-*
                                     expt_gamma_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                (binary-*
                                                     '1
                                                     (unary-/ '1)))))))))))))
                                   h)
                                  ((lambda
                                    (|var1|)
                                    (binary-*
                                     expt_gamma_minus_h
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                (binary-*
                                                     '1
                                                     (unary-/ '1)))))))))))))
                                   (unary-- h)))
                                 '0)))
                              (expt (binary-* '1 (unary-/ '2))
                                    (unary-- |var0|))
                              (expt (binary-* '1 (unary-/ '2))
                                    (unary-- |var1|))
                              h))
                            (implies (if (integerp h) (< '2 h) 'nil)
                                     (< (binary-+ (b-term h)
                                                  (b-term (unary-- h)))
                                        '0)))
                           ((implies
                              (if (integerp h)
                                  (if (equal expt_gamma_h
                                             (expt (binary-* '1 (unary-/ '2))
                                                   (unary-- |var0|)))
                                      (< '2 h)
                                      'nil)
                                  'nil)
                              (rationalp expt_gamma_h))
                            (implies
                              (if (integerp h)
                                  (if (equal expt_gamma_minus_h
                                             (expt (binary-* '1 (unary-/ '2))
                                                   (unary-- |var1|)))
                                      (< '2 h)
                                      'nil)
                                  'nil)
                              (rationalp expt_gamma_minus_h))))

 Success!


ACL2 Error in ( defthm b-term-neg ...):  The :CLAUSE-PROCESSOR hint

  (my-clause-processor
       clause
       '((:expand (b-term gamma mu equ-c))
         (:python-file "B-term-neg")
         (:let ((expt_gamma_h (expt (binary-* '1 (unary-/ '2))
                                    (unary-- |var0|))
                              rationalp)
                (expt_gamma_minus_h (expt (binary-* '1 (unary-/ '2))
                                          (unary-- |var1|))
                                    rationalp)))
         (:hypothesize ((< expt_gamma_h 1)
                        (> expt_gamma_h 0)
                        (< expt_gamma_minus_h 1)
                        (> expt_gamma_minus_h 0)))))

did not evaluate to a list of clauses, but instead to

  (((not
     ((lambda
       (expt_gamma_h expt_gamma_minus_h h)
       (implies
        (if (if (rationalp expt_gamma_minus_h)
                (if (rationalp expt_gamma_h)
                    (integerp h)
                    'nil)
                'nil)
            (if (< '0 expt_gamma_minus_h)
                (if (< expt_gamma_minus_h '1)
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1) (< '2 h) 'nil)
                        'nil)
                    'nil)
                'nil)
            'nil)
        (<
         (binary-+
          ((lambda
            (|var0|)
            (binary-*
             expt_gamma_h
             (binary-+
              '-1
              (binary-*
               (binary-* '1 (unary-/ (binary-* '1 '1)))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var0| '1/3200)
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
           h)
          ((lambda
            (|var1|)
            (binary-*
             expt_gamma_minus_h
             (binary-+
              '-1
              (binary-*
               (binary-* '1 (unary-/ (binary-* '1 '1)))
               (binary-*
                (binary-+ '1 (binary-* '1 '1))
                (unary-/
                 (binary-+
                  '1
                  (binary-*
                   '1
                   (binary-+
                    (binary-* |var1| '1/3200)
                    (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
           (unary-- h)))
         '0)))
      (expt (binary-* '1 (unary-/ '2))
            (unary-- |var0|))
      (expt (binary-* '1 (unary-/ '2))
            (unary-- |var1|))
      h))
    (implies (if (integerp h) (< '2 h) 'nil)
             (< (binary-+ (b-term h)
                          (b-term (unary-- h)))
                '0)))
   ((implies (if (integerp h)
                 (if (equal expt_gamma_h
                            (expt (binary-* '1 (unary-/ '2))
                                  (unary-- |var0|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_h))
    (implies (if (integerp h)
                 (if (equal expt_gamma_minus_h
                            (expt (binary-* '1 (unary-/ '2))
                                  (unary-- |var1|)))
                     (< '2 h)
                     'nil)
                 'nil)
             (rationalp expt_gamma_minus_h))))

which has a member

  ((not
    ((lambda
      (expt_gamma_h expt_gamma_minus_h h)
      (implies
       (if (if (rationalp expt_gamma_minus_h)
               (if (rationalp expt_gamma_h)
                   (integerp h)
                   'nil)
               'nil)
           (if (< '0 expt_gamma_minus_h)
               (if (< expt_gamma_minus_h '1)
                   (if (< '0 expt_gamma_h)
                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                       'nil)
                   'nil)
               'nil)
           'nil)
       (<
        (binary-+
         ((lambda
           (|var0|)
           (binary-*
            expt_gamma_h
            (binary-+
             '-1
             (binary-*
              (binary-* '1 (unary-/ (binary-* '1 '1)))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var0| '1/3200)
                   (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
          h)
         ((lambda
           (|var1|)
           (binary-*
            expt_gamma_minus_h
            (binary-+
             '-1
             (binary-*
              (binary-* '1 (unary-/ (binary-* '1 '1)))
              (binary-*
               (binary-+ '1 (binary-* '1 '1))
               (unary-/
                (binary-+
                 '1
                 (binary-*
                  '1
                  (binary-+
                   (binary-* |var1| '1/3200)
                   (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
          (unary-- h)))
        '0)))
     (expt (binary-* '1 (unary-/ '2))
           (unary-- |var0|))
     (expt (binary-* '1 (unary-/ '2))
           (unary-- |var1|))
     h))
   (implies (if (integerp h) (< '2 h) 'nil)
            (< (binary-+ (b-term h)
                         (b-term (unary-- h)))
               '0)))

that contains the following non-termp (see :DOC term):

  (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         (unary-- h)))
       '0)))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var0|))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var1|))
    h))



Summary
Form:  ( defthm b-term-neg ...)
Rules: nil
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)

*** Note: No checkpoints to print. ***

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(termp (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         (unary-- h)))
       '0)))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var0|))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var1|))
    h)))


ACL2 Error in top-level:  termp takes 2 arguments but in the call 
(termp (not ((lambda (expt_gamma_h expt_gamma_minus_h h)
                     (implies # #))
             (expt (binary-* # #) (unary-- |var0|))
             (expt (binary-* # #) (unary-- |var1|))
             h)))
it is given 1 argument.   The formal parameters list for termp is (x w).
(See :DOC set-iprint to be able to see elided values in this message.)

ACL2 !>(termp (not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         (unary-- h)))
       '0)))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var0|))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var1|))
    h)) (w state))


ACL2 Error in top-level:  Global variables, such as h, |var1| and |var0|,
are not allowed. See :DOC ASSIGN and :DOC @.

ACL2 !>(termp (and a b) (w state))


ACL2 Error in top-level:  Global variables, such as b and a, are not
allowed. See :DOC ASSIGN and :DOC @.

ACL2 !>(termp '(and  a b) (w state))
nil
ACL2 !>(termp '(not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         (unary-- h)))
       '0)))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var0|))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var1|))
    h)) (w state))
nil
ACL2 !>(termp '(implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         (unary-- h)))
       '0)) (w state))
nil
ACL2 !>(termp '
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h) (s state))


ACL2 Error in top-level:  The symbol s (in package "ACL2") has neither
a function nor macro definition in ACL2.  Please define it.  Note:
this error occurred in the context (s state).

ACL2 !>(termp '
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h) (w state))
nil
ACL2 !>(termp '(binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))) (s state))


ACL2 Error in top-level:  The symbol s (in package "ACL2") has neither
a function nor macro definition in ACL2.  Please define it.  Note:
this error occurred in the context (s state).

ACL2 !>(termp '(binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))) (w state))
t
ACL2 !>(termp '(binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))) (w state))
t
ACL2 !>(termp '(binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))) (w state))
t
ACL2 !>(termp '(binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))) (w state))
t
ACL2 !>(termp '((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h) (w state))
nil
ACL2 !>(termp '((lambda
          (var0)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h) (w state))
nil
ACL2 !>(termp '((lambda
          (|var0| expt_gamma_h)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h 3) (w state))
nil
ACL2 !>(termp '((lambda
          (|var0| expt_gamma_h)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h k) (w state))
t
ACL2 !>(termp '(not
   ((lambda
     (expt_gamma_h expt_gamma_minus_h h)
     (implies
      (if (if (rationalp expt_gamma_minus_h)
              (if (rationalp expt_gamma_h)
                  (integerp h)
                  'nil)
              'nil)
          (if (< '0 expt_gamma_minus_h)
              (if (< expt_gamma_minus_h '1)
                  (if (< '0 expt_gamma_h)
                      (if (< expt_gamma_h '1) (< '2 h) 'nil)
                      'nil)
                  'nil)
              'nil)
          'nil)
      (<
       (binary-+
        ((lambda
          (|var0|)
          (binary-*
           expt_gamma_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var0| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         h)
        ((lambda
          (|var1|)
          (binary-*
           expt_gamma_minus_h
           (binary-+
            '-1
            (binary-*
             (binary-* '1 (unary-/ (binary-* '1 '1)))
             (binary-*
              (binary-+ '1 (binary-* '1 '1))
              (unary-/
               (binary-+
                '1
                (binary-*
                 '1
                 (binary-+
                  (binary-* |var1| '1/3200)
                  (binary-+
                     (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                     (unary-- (binary-* '1 (unary-/ '1)))))))))))))
         (unary-- h)))
       '0)))?
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var0|))
    (expt (binary-* '1 (unary-/ '2))
          (unary-- |var1|))
    h)) (w state))
nil
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:33:44 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.33 seconds (prove: 0.00, print: 0.00, other: 4.33)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>

ACL2 Error in ( defun b-term-expt ...):  The symbol -h (in package
"ACL2") has neither a function nor macro definition in ACL2.  Please
define it.  Note:  this error occurred in the context (-h).


Summary
Form:  ( defun b-term-expt ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( defun b-term-expt ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:34:13 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.45 seconds (prove: 0.00, print: 0.00, other: 0.45)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.38 seconds (prove: 0.00, print: 0.00, other: 4.38)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(defthm
              b-term-neg
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbols b-term-expt and b-term-rest.  Unless
these functions are disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies
                           (if (integerp h) (< '2 h) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
rewritten: (implies (if (if (rationalp expt_gamma_minus_h)
                            (if (rationalp expt_gamma_h)
                                (integerp h)
                                'nil)
                            'nil)
                        (if (< '0 expt_gamma_minus_h)
                            (if (< expt_gamma_minus_h '1)
                                (if (< '0 expt_gamma_h)
                                    (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                    'nil)
                                'nil)
                            'nil)
                        'nil)
                    (< (binary-+ (binary-* expt_gamma_h (b-term-rest h))
                                 (binary-* expt_gamma_minus_h
                                           (b-term-rest (unary-- h))))
                       '0))
Expanded(SMT-z3): (implies
                       (if (if (rationalp expt_gamma_minus_h)
                               (if (rationalp expt_gamma_h)
                                   (integerp h)
                                   'nil)
                               'nil)
                           (if (< '0 expt_gamma_minus_h)
                               (if (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                               'nil)
                           'nil)
                       (< (binary-+ (binary-* expt_gamma_h (b-term-rest h))
                                    (binary-* expt_gamma_minus_h
                                              (b-term-rest (unary-- h))))
                          '0))
Final index number: 0
Error(formula): This is not a valid operator: (b-term-rest h)
Error(formula): This is not a valid operator: (b-term-rest (unary-- h))
Traceback (most recent call last):
  File "z3_files/B-term-neg.py", line 9, in <module>
    conclusion=s.lt(s.plus(s.times(EXPT_GAMMA_H,False),s.times(EXPT_GAMMA_MINUS_H,False)),0)
  File "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py", line 50, in times
    return reduce(lambda x, y: x*y, args)
  File "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py", line 50, in <lambda>
    return reduce(lambda x, y: x*y, args)
  File "src/api/python/z3.py", line 1871, in __mul__
  File "src/api/python/z3.py", line 870, in _coerce_exprs
  File "src/api/python/z3.py", line 1781, in cast
  File "src/api/python/z3.py", line 2564, in RealVal
  File "src/api/python/z3core.py", line 1852, in Z3_mk_numeral
z3types.Z3Exception: 'parser error'
; Z3: `python z3_files/B-term-neg.py`: 0.14 sec, 5,600 bytes
Z3 failure: ("Traceback (most recent call last):"
             "  File \"z3_files/B-term-neg.py\", line 9, in <module>"
             "    conclusion=s.lt(s.plus(s.times(EXPT_GAMMA_H,False),s.times(EXPT_GAMMA_MINUS_H,False)),0)"
             "  File \"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py\", line 50, in times"
             "    return reduce(lambda x, y: x*y, args)"
             "  File \"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/z3_interface/ACL2_translator.py\", line 50, in <lambda>"
             "    return reduce(lambda x, y: x*y, args)"
             "  File \"src/api/python/z3.py\", line 1871, in __mul__"
             "  File \"src/api/python/z3.py\", line 870, in _coerce_exprs"
             "  File \"src/api/python/z3.py\", line 1781, in cast"
             "  File \"src/api/python/z3.py\", line 2564, in RealVal"
             "  File \"src/api/python/z3core.py\", line 1852, in Z3_mk_numeral"
             "z3types.Z3Exception: 'parser error'")

NOTE: Unable to prove goal with my-clause-processor and indicated hint.
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (- (/ (expt 2 (+ -1 h))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h))))
                    (* 2 (/ (expt 2 (+ -1 h)))
                       (/ (+ 6401/3200 (- (* 1/3200 h))))))
                 (expt 2 (+ -1 h)))
              (integerp h)
              (< 2 h))
         (< (+ (- (* 1/2 (/ (expt 2 (+ -1 h)))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h))))
               (* (/ (expt 2 (+ -1 h)))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (* 2 (expt 2 (+ -1 h)))))

*1.1 (Subgoal *1/5'8') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (rationalp s)
              (< s 0)
              (integerp j)
              (< 0 j)
              (rationalp r)
              (< 0 r)
              (integerp i)
              (< 0 i)
              (< 0 h)
              (< (+ (- k)
                    (* 2 j (/ (+ 6399/3200 r)))
                    (* 2 k (/ (+ 6401/3200 s))))
                 j)
              (integerp h)
              (< 2 h))
         (< (+ (- (* 1/2 k))
               (* k (/ (+ 2 s)))
               (* 4 j (/ (+ 2 r))))
            (* 2 j))).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite <-+-negative-0-1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.01, other: 0.00)
Prover steps counted:  6712

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (- (/ (expt 2 (+ -1 h))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h))))
                    (* 2 (/ (expt 2 (+ -1 h)))
                       (/ (+ 6401/3200 (- (* 1/3200 h))))))
                 (expt 2 (+ -1 h)))
              (integerp h)
              (< 2 h))
         (< (+ (- (* 1/2 (/ (expt 2 (+ -1 h)))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h))))
               (* (/ (expt 2 (+ -1 h)))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (* 2 (expt 2 (+ -1 h)))))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.18 seconds (prove: 0.16, print: 0.01, other: 0.01)
Prover steps counted:  7591

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:35:32 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.41 seconds (prove: 0.00, print: 0.00, other: 4.41)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(defthm
              b-term-neg
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbols b-term-expt and b-term-rest.  Unless
these functions are disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies
                           (if (integerp h) (< '2 h) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (binary-*
               expt_gamma_h
               ((lambda
                 (|var0|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                h))
              (binary-*
               expt_gamma_minus_h
               ((lambda
                 (|var1|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                (unary-- h))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (binary-*
                      expt_gamma_h
                      ((lambda
                        (|var0|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       h))
                     (binary-*
                      expt_gamma_minus_h
                      ((lambda
                        (|var1|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       (unary-- h))))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.13 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  (binary-*
                                   expt_gamma_h
                                   ((lambda
                                     (|var0|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    h))
                                  (binary-*
                                   expt_gamma_minus_h
                                   ((lambda
                                     (|var1|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    (unary-- h))))
                                 '0)))
                              (b-term-expt h)
                              (b-term-expt (unary-- h))
                              h))
                            (implies
                             (if (integerp h) (< '2 h) 'nil)
                             (<
                              (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0)))
                           ((implies
                                 (if (integerp h)
                                     (if (equal expt_gamma_h (b-term-expt h))
                                         (< '2 h)
                                         'nil)
                                     'nil)
                                 (rationalp expt_gamma_h))
                            (implies
                                 (if (integerp h)
                                     (if (equal expt_gamma_minus_h
                                                (b-term-expt (unary-- h)))
                                         (< '2 h)
                                         'nil)
                                     'nil)
                                 (rationalp expt_gamma_minus_h))))

 Success!
Subgoal 2
Subgoal 2'
Subgoal 2''

([ A key checkpoint:

Subgoal 2''
(implies (and (integerp h) (< 2 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

Normally we would attempt to prove Subgoal 2'' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-left)
        (:rewrite <-unary-/-positive-right)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite times-zero)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1761

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 2''
(implies (and (integerp h) (< 2 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.06 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2640

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:38:55 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(defthm
              b-term-neg
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbols b-term-expt and b-term-rest.  Unless
these functions are disabled, this rule is unlikely ever to be used.

Original clause(connect): (implies
                           (if (integerp h) (< '2 h) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1) (< '2 h) 'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (binary-*
               expt_gamma_h
               ((lambda
                 (|var0|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                h))
              (binary-*
               expt_gamma_minus_h
               ((lambda
                 (|var1|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                (unary-- h))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (binary-*
                      expt_gamma_h
                      ((lambda
                        (|var0|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       h))
                     (binary-*
                      expt_gamma_minus_h
                      ((lambda
                        (|var1|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       (unary-- h))))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.15 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                  (< '0 expt_gamma_minus_h)
                                  (if
                                   (< expt_gamma_minus_h '1)
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1) (< '2 h) 'nil)
                                       'nil)
                                   'nil)
                                  'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  (binary-*
                                   expt_gamma_h
                                   ((lambda
                                     (|var0|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    h))
                                  (binary-*
                                   expt_gamma_minus_h
                                   ((lambda
                                     (|var1|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    (unary-- h))))
                                 '0)))
                              (b-term-expt h)
                              (b-term-expt (unary-- h))
                              h))
                            (implies
                             (if (integerp h) (< '2 h) 'nil)
                             (<
                              (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0)))
                           (implies
                                (if (integerp h)
                                    (if (equal expt_gamma_h (b-term-expt h))
                                        (< '2 h)
                                        'nil)
                                    'nil)
                                (rationalp expt_gamma_h))
                           (implies (if (integerp h)
                                        (if (equal expt_gamma_minus_h
                                                   (b-term-expt (unary-- h)))
                                            (< '2 h)
                                            'nil)
                                        'nil)
                                    (rationalp expt_gamma_minus_h)))

 Success!
Subgoal 3
Subgoal 3'
Subgoal 3''

([ A key checkpoint:

Subgoal 3''
(implies (and (integerp h) (< 2 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

Normally we would attempt to prove Subgoal 3'' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-left)
        (:rewrite <-unary-/-positive-right)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite times-zero)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1761

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 3''
(implies (and (integerp h) (< 2 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.06 seconds (prove: 0.05, print: 0.00, other: 0.01)
Prover steps counted:  2640

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:44:45 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proof
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))


ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  The form 
(skip-proof
 (defthm b-term-neg-lemma3
         (implies (and (integerp h) (> h 2))
                  (< (+ # #) 0))
         :hints (("Goal" :clause-processor (my-clause-processor clause #)))))
is not an embedded event form.  See :DOC embedded-event-form.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.01)
Prover steps counted:  879

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:45:22 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.41 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.29 seconds (prove: 0.00, print: 0.00, other: 4.29)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0)))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (integerp j)
              (< 0 j)
              (rationalp s)
              (< s 0)
              (integerp i)
              (< 0 i)
              (rationalp r)
              (< 0 r)
              (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 s)))
                    (- (* j (denominator k)))
                    (* 2 j (denominator k)
                       (/ (+ 6399/3200 r))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 s)))
               (- (* 2 j (denominator (* 1/2 k))))
               (* 4 j (/ (+ 2 r))
                  (denominator (* 1/2 k))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.14 seconds (prove: 0.13, print: 0.01, other: 0.00)
Prover steps counted:  7866

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* (expt 2 h)
                     (denominator (/ (expt 2 h)))))
               (* 2 (expt 2 h)
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (/ (expt 2 h)))))
            1))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (* 2 (/ (+ 6401/3200 (- (* 1/3200 h)))))
                    (- (* (expt 2 (+ -1 h))
                          (denominator (/ (expt 2 (+ -1 h))))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h)))
                       (denominator (/ (expt 2 (+ -1 h))))))
                 1)
              (integerp h)
              (< 2 h))
         (< (+ (* 2 (/ (+ 2 (- (* 1/3200 h)))))
               (- (* 2 (expt 2 (+ -1 h))
                     (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 h)))))))
            1))

ACL2 Error in ( defthm b-term-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Skip-proofs, Subsume and Non-rec
Time:  0.16 seconds (prove: 0.14, print: 0.01, other: 0.02)
Prover steps counted:  8745

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-byE
)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:47:45 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
ACL2 Warning [Non-rec] in ( defthm b-neg ...):  A :rewrite rule generated
from b-neg will be triggered only by terms containing the non-recursive
function symbol b.  Unless this function is disabled, this rule is
unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  One induction scheme is suggested
by this conjecture.  

We will induct according to a scheme suggested by (expt '2 n).  This
suggestion was produced using the :induction rule expt.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip n))
                   (not (= (fix 2) 0))
                   (<= n 0)
                   (:p (+ n 1)))
              (:p n))
     (implies (and (not (zip n))
                   (not (= (fix 2) 0))
                   (< 0 n)
                   (:p (+ n -1)))
              (:p n))
     (implies (and (not (zip n)) (= (fix 2) 0))
              (:p n))
     (implies (zip n) (:p n))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 n)
              (< (* 8 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
                 0)
              (integerp n)
              (< 2 n))
         (< (+ (* 4 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
               (- (* 16 (/ (expt 2 n)) (/ (expt 2 n))))
               (* 2 (/ (expt 2 n))
                  (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 32 (/ (expt 2 n))
                  (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (acl2-numberp b*)
              (rationalp r)
              (< 0 r)
              (integerp j)
              (< 0 j)
              (< 0 n)
              (< (* 8 b*) 0)
              (integerp n)
              (< 2 n))
         (< (+ (* 4 b*)
               (- (* 16 r r))
               (* 2 r (denominator r)
                  (/ (+ 3199/1600 (* 1/3200 n))))
               (* 32
                  r r (/ (+ 3201/1600 (- (* 1/3200 n))))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b)
        (:definition b-sum)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite *-r-denominator-r)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-0-+-negative-1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription b-sum)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.17 seconds (prove: 0.16, print: 0.01, other: 0.00)
Prover steps counted:  11829

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 n)
              (< (* 8 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
                 0)
              (integerp n)
              (< 2 n))
         (< (+ (* 4 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
               (- (* 16 (/ (expt 2 n)) (/ (expt 2 n))))
               (* 2 (/ (expt 2 n))
                  (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 32 (/ (expt 2 n))
                  (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            1))

ACL2 Error in ( defthm b-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:06:03 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.51 seconds (prove: 0.00, print: 0.00, other: 4.51)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Splitter note (see :DOC splitter) for Goal'' (4 subgoals).
  if-intro: ((:definition fix))

Subgoal 4

([ A key checkpoint:

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

Normally we would attempt to prove Subgoal 4 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-+)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:use b-term-neg))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix))
Warnings:  Use
Time:  0.05 seconds (prove: 0.05, print: 0.00, other: 0.00)
Prover steps counted:  3812

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:08:05 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.38 seconds (prove: 0.00, print: 0.00, other: 4.38)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
***********************************************
************ ABORTING from raw Lisp ***********
Error:  Reader error on #<BASIC-FILE-CHARACTER-INPUT-STREAM ("/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/foo.lisp"/5 ISO-8859-1) #x302002550CED>, near position 2367, within " n) 0)))
)
":
Unmatched ')' near position 2367.
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:08:40 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.44 seconds (prove: 0.00, print: 0.00, other: 4.44)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.00, print: 0.00, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>Bye.
 :eof
ACL2 !>(defthm B-sum-neg
   (implies (and (integerp n) (> n 2)) (< (B-sum 1 (- n 2)) 0))
   :hints (("Goal"
 	   :use ((:instance B-term-neg)))))

ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Splitter note (see :DOC splitter) for Goal'' (4 subgoals).
  if-intro: ((:definition fix))

Subgoal 4

([ A key checkpoint:

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

Normally we would attempt to prove Subgoal 4 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-+)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:use b-term-neg))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix))
Warnings:  Use
Time:  0.05 seconds (prove: 0.05, print: 0.00, other: 0.00)
Prover steps counted:  3812

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:10:58 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.47 seconds (prove: 0.00, print: 0.00, other: 4.47)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>

ACL2 Error in ( defthm b-sum-neg ...):  We do not support the use of
an :INDUCT hint with a :USE hint.  When a subgoal with an :INDUCT hint
arises, we push it for proof by induction.  Upon popping it, we interpret
the :INDUCT hint to determine the induction and we also install any
other non-:USE hints supplied.  On the other hand, when a subgoal with
a :USE hint arises, we augment the formula with the additional hypotheses
supplied by the hint.  If both an :INDUCT and a :USE hint were attached
to the same subgoal we could either add the hypotheses before induction,
which is generally detrimental to a successful induction, or add them
to each of the formulas produced by the induction, which generally
adds the hypotheses in many more places than they are needed.  We therefore
do neither and cause this neat, informative error.  You are encouraged
to attach the :INDUCT hint to the goal or subgoal to which you want
us to apply induction and then attach :USE hints to the individual
subgoals produced, as necessary.  For what it is worth, :INDUCT hints
get along just fine with hints besides :USE.  For example, an :INDUCT
hint and an :IN-THEORY hint would cause an induction and set the post-
induction locally enabled theory to be as specified by the :IN-THEORY.


Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:11:57 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.41 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.46 seconds (prove: 0.00, print: 0.00, other: 4.46)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo hi).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(implies (or (not (integerp hi))
             (not (integerp lo))
             (< hi lo))
         (:p n)).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.
Subgoal *1/
Subgoal *1/'

Splitter note (see :DOC splitter) for Subgoal *1/' (3 subgoals).
  if-intro: ((:definition not))

Subgoal *1/3
Subgoal *1/3'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.1 (Subgoal *1/3') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2
(implies (and (< hi lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/2') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1') is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.1, which we'll try to prove
later.  We therefore regard *1.2 as proved (pending the proof of the
more general *1.1).

Subgoal *1/2 COMPLETED!

We next consider *1.1, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition not)
        (:executable-counterpart not)
        (:induction b-sum))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.07 seconds (prove: 0.07, print: 0.00, other: 0.00)
Prover steps counted:  6184

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(goo-dbye)


ACL2 Error in top-level:  The symbol goo-dbye (in package "ACL2") has
neither a function nor macro definition in ACL2.  Please define it.
Note:  this error occurred in the context (goo-dbye).

ACL2 !>acl2


ACL2 Error in top-level:  Global variables, such as acl2, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:14:21 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.38 seconds (prove: 0.00, print: 0.00, other: 4.38)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  712

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[15:20:39 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2805
 t
ACL2 !>> b-sum-neg
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-neg-lemma1
                        (equal (b n)
                               (* (b-expt n) (b-sum 1 (- n 2))))))

ACL2 Warning [Non-rec] in ( defthm b-neg-lemma1 ...):  A :rewrite rule
generated from b-neg-lemma1 will be triggered only by terms containing
the non-recursive function symbol b.  Unless this function is disabled,
this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-neg-lemma1 ...)
Rules: ((:definition b)
        (:definition b-expt)
        (:executable-counterpart gamma)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-of-*)
        (:rewrite functional-commutativity-of-expt-/-base))
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1489
b-neg-lemma1


ACL2 !>>>(defthm b-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b n) 0)))

ACL2 Warning [Non-rec] in ( defthm b-neg ...):  A :rewrite rule generated
from b-neg will be triggered only by terms containing the non-recursive
function symbol b.  Unless this function is disabled, this rule is
unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  One induction scheme is suggested
by this conjecture.  

We will induct according to a scheme suggested by (expt '2 n).  This
suggestion was produced using the :induction rule expt.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip n))
                   (not (= (fix 2) 0))
                   (<= n 0)
                   (:p (+ n 1)))
              (:p n))
     (implies (and (not (zip n))
                   (not (= (fix 2) 0))
                   (< 0 n)
                   (:p (+ n -1)))
              (:p n))
     (implies (and (not (zip n)) (= (fix 2) 0))
              (:p n))
     (implies (zip n) (:p n))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 n)
              (< (* 8 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
                 0)
              (integerp n)
              (< 2 n))
         (< (+ (* 4 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
               (- (* 16 (/ (expt 2 n)) (/ (expt 2 n))))
               (* 2 (/ (expt 2 n))
                  (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 32 (/ (expt 2 n))
                  (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            1))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (acl2-numberp b*)
              (rationalp r)
              (< 0 r)
              (integerp j)
              (< 0 j)
              (< 0 n)
              (< (* 8 b*) 0)
              (integerp n)
              (< 2 n))
         (< (+ (* 4 b*)
               (- (* 16 r r))
               (* 2 r (denominator r)
                  (/ (+ 3199/1600 (* 1/3200 n))))
               (* 32
                  r r (/ (+ 3201/1600 (- (* 1/3200 n))))))
            1)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-expt)
        (:definition b-sum)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite *-r-denominator-r)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-0-+-negative-1)
        (:rewrite associativity-of-*)
        (:rewrite b-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription b-sum)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Warnings:  Non-rec
Time:  0.17 seconds (prove: 0.16, print: 0.01, other: 0.00)
Prover steps counted:  11831

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 n)
              (< (* 8 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
                 0)
              (integerp n)
              (< 2 n))
         (< (+ (* 4 (/ (expt 2 n)) (b-sum 1 (+ -3 n)))
               (- (* 16 (/ (expt 2 n)) (/ (expt 2 n))))
               (* 2 (/ (expt 2 n))
                  (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 32 (/ (expt 2 n))
                  (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            1))

ACL2 Error in ( defthm b-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Non-rec
Time:  0.20 seconds (prove: 0.18, print: 0.01, other: 0.01)
Prover steps counted:  13320

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:21:00 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.36 seconds (prove: 0.00, print: 0.00, other: 4.36)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>> b-sum-neg
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-neg-lemma1
                        (equal (b n)
                               (* (b-expt n) (b-sum 1 (- n 2))))))

ACL2 Warning [Non-rec] in ( defthm b-neg-lemma1 ...):  A :rewrite rule
generated from b-neg-lemma1 will be triggered only by terms containing
the non-recursive function symbol b.  Unless this function is disabled,
this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-neg-lemma1 ...)
Rules: ((:definition b)
        (:definition b-expt)
        (:executable-counterpart gamma)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-of-*)
        (:rewrite functional-commutativity-of-expt-/-base))
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1489
b-neg-lemma1


ACL2 !>>>(local (defthm b-expt->-0
                        (implies (and (integerp n) (> n 2))
                                 (> (b-expt n) 0))))

ACL2 Warning [Non-rec] in ( defthm b-expt->-0 ...):  A :rewrite rule
generated from b-expt->-0 will be triggered only by terms containing
the non-recursive function symbol b-expt.  Unless this function is
disabled, this rule is unlikely ever to be used.


Q.E.D.

The storage of b-expt->-0 depends upon primitive type reasoning and
the :type-prescription rule b-expt.

Summary
Form:  ( defthm b-expt->-0 ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription b-expt))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
b-expt->-0


ACL2 !>>>(defthm b-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b n) 0))
                 :hints (("Goal" :use ((:instance (b-sum-neg))))))

ACL2 Warning [Non-rec] in ( defthm b-neg ...):  A :rewrite rule generated
from b-neg will be triggered only by terms containing the non-recursive
function symbol b.  Unless this function is disabled, this rule is
unlikely ever to be used.



ACL2 Error in ( defthm b-neg ...):  The object (b-sum-neg) is an ill-
formed lemma instance because is not a symbol, a rune in the current
logical world, or a list whose first element is :THEOREM, :INSTANCE,
or :FUNCTIONAL-INSTANCE.  See :DOC lemma-instance.


Summary
Form:  ( defthm b-neg ...)
Rules: nil
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( defthm b-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1489

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:22:25 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.35 seconds (prove: 0.00, print: 0.00, other: 4.35)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>> b-sum-neg
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-neg-lemma1
                        (equal (b n)
                               (* (b-expt n) (b-sum 1 (- n 2))))))

ACL2 Warning [Non-rec] in ( defthm b-neg-lemma1 ...):  A :rewrite rule
generated from b-neg-lemma1 will be triggered only by terms containing
the non-recursive function symbol b.  Unless this function is disabled,
this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-neg-lemma1 ...)
Rules: ((:definition b)
        (:definition b-expt)
        (:executable-counterpart gamma)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-of-*)
        (:rewrite functional-commutativity-of-expt-/-base))
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1489
b-neg-lemma1


ACL2 !>>>(local (defthm b-expt->-0
                        (implies (and (integerp n) (> n 2))
                                 (> (b-expt n) 0))))

ACL2 Warning [Non-rec] in ( defthm b-expt->-0 ...):  A :rewrite rule
generated from b-expt->-0 will be triggered only by terms containing
the non-recursive function symbol b-expt.  Unless this function is
disabled, this rule is unlikely ever to be used.


Q.E.D.

The storage of b-expt->-0 depends upon primitive type reasoning and
the :type-prescription rule b-expt.

Summary
Form:  ( defthm b-expt->-0 ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription b-expt))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
b-expt->-0


ACL2 !>>>(defthm b-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b n) 0))
                 :hints (("Goal" :use ((:instance b-neg-lemma1)
                                       (:instance b-expt->-0)
                                       (:instance b-sum-neg)))))

ACL2 Warning [Non-rec] in ( defthm b-neg ...):  A :rewrite rule generated
from b-neg will be triggered only by terms containing the non-recursive
function symbol b.  Unless this function is disabled, this rule is
unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-neg ...):  It is unusual to :USE an
enabled :REWRITE or :DEFINITION rule, so you may want to consider disabling
(:rewrite b-neg-lemma1), (:rewrite b-expt->-0) and (:rewrite b-sum-neg)
in the hint provided for Goal.  See :DOC using-enabled-rules.

Goal'
Goal''
Goal'''

([ A key checkpoint:

Goal'''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

Normally we would attempt to prove Goal''' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-neg ...)
Rules: ((:definition b-expt)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-*-/-right)
        (:rewrite b-neg-lemma1)
        (:rewrite b-sum-neg)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite exponents-add)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite times-zero)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-expt->-0)
              (:use b-neg-lemma1)
              (:use b-sum-neg))
Warnings:  Use and Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  3710

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Goal'''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

ACL2 Error in ( defthm b-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use and Non-rec
Time:  0.07 seconds (prove: 0.06, print: 0.00, other: 0.01)
Prover steps counted:  5199

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(thm (implies (and (> a 0) (< b 0)) (< (* a b) 0)))
Goal'

([ A key checkpoint:

Goal'
(implies (and (< 0 a) (< b 0))
         (< (* a b) 0))

*1 (Goal') is pushed for proof by induction.

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( THM ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  100

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (< 0 a) (< b 0))
         (< (* a b) 0))

ACL2 Error in ( THM ...):  See :DOC failure.

******** FAILED ********
ACL2 !>(thm (implies (and (rationalp a) (rationalp b) (> a 0) (< b 0)) (< (* a b) 0)))

Q.E.D.

Summary
Form:  ( THM ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

Proof succeeded.
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:29:45 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.32 seconds (prove: 0.00, print: 0.00, other: 4.32)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>> b-sum-neg
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b n)
                                        (* (b-expt n) (b-sum 1 (- n 2)))))))

ACL2 Warning [Non-rec] in ( defthm b-neg-lemma1 ...):  A :rewrite rule
generated from b-neg-lemma1 will be triggered only by terms containing
the non-recursive function symbol b.  Unless this function is disabled,
this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-neg-lemma1 ...)
Rules: ((:definition b)
        (:definition b-expt)
        (:definition synp)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite exponents-add)
        (:rewrite functional-commutativity-of-expt-/-base))
Warnings:  Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1530
b-neg-lemma1


ACL2 !>>>(local (defthm b-expt->-0
                        (implies (and (integerp n) (> n 2))
                                 (> (b-expt n) 0))))

ACL2 Warning [Non-rec] in ( defthm b-expt->-0 ...):  A :rewrite rule
generated from b-expt->-0 will be triggered only by terms containing
the non-recursive function symbol b-expt.  Unless this function is
disabled, this rule is unlikely ever to be used.


Q.E.D.

The storage of b-expt->-0 depends upon primitive type reasoning and
the :type-prescription rule b-expt.

Summary
Form:  ( defthm b-expt->-0 ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription b-expt))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
b-expt->-0


ACL2 !>>>(defthm b-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b n) 0))
                 :hints (("Goal" :use ((:instance b-neg-lemma1)
                                       (:instance b-expt->-0)
                                       (:instance b-sum-neg)))))

ACL2 Warning [Non-rec] in ( defthm b-neg ...):  A :rewrite rule generated
from b-neg will be triggered only by terms containing the non-recursive
function symbol b.  Unless this function is disabled, this rule is
unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-neg ...):  It is unusual to :USE an
enabled :REWRITE or :DEFINITION rule, so you may want to consider disabling
(:rewrite b-neg-lemma1), (:rewrite b-expt->-0) and (:rewrite b-sum-neg)
in the hint provided for Goal.  See :DOC using-enabled-rules.

Goal'
Goal''
Goal'''

([ A key checkpoint:

Goal'''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

Normally we would attempt to prove Goal''' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-neg ...)
Rules: ((:definition b-expt)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-*-/-right)
        (:rewrite b-neg-lemma1)
        (:rewrite b-sum-neg)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite exponents-add)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite times-zero)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-expt->-0)
              (:use b-neg-lemma1)
              (:use b-sum-neg))
Warnings:  Use and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  3645

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Goal'''
(implies (and (integerp n) (< 2 n))
         (< (* 4 (/ (expt 2 n)) (b-sum 1 (+ -2 n)))
            0))

ACL2 Error in ( defthm b-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use and Non-rec
Time:  0.08 seconds (prove: 0.06, print: 0.00, other: 0.01)
Prover steps counted:  5175

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:42:09 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.39 seconds (prove: 0.00, print: 0.00, other: 4.39)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo hi).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(implies (or (not (integerp hi))
             (not (integerp lo))
             (< hi lo))
         (:p n)).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.
Subgoal *1/
Subgoal *1/'

Splitter note (see :DOC splitter) for Subgoal *1/' (3 subgoals).
  if-intro: ((:definition not))

Subgoal *1/3
Subgoal *1/3'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.1 (Subgoal *1/3') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2
(implies (and (< hi lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/2') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1') is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.1, which we'll try to prove
later.  We therefore regard *1.2 as proved (pending the proof of the
more general *1.1).

Subgoal *1/2 COMPLETED!

We next consider *1.1, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition not)
        (:executable-counterpart not)
        (:induction b-sum))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.08 seconds (prove: 0.07, print: 0.01, other: 0.00)
Prover steps counted:  6184

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:44:46 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Splitter note (see :DOC splitter) for Goal'' (4 subgoals).
  if-intro: ((:definition fix))

Subgoal 4

([ A key checkpoint:

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

Normally we would attempt to prove Subgoal 4 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-+)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:use b-term-neg))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix))
Warnings:  Use
Time:  0.05 seconds (prove: 0.05, print: 0.00, other: 0.00)
Prover steps counted:  3812

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:45:36 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.32 seconds (prove: 0.00, print: 0.00, other: 4.32)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2805
 t
ACL2 !>>
ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''
Goal'''

([ A key checkpoint:

Goal'''
(implies (and (< (+ (* 2 (/ (+ 2 (- (* 1/3200 n)))))
                    (- (* (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 2 (expt 2 n)
                       (/ (+ 2 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 1)
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

Normally we would attempt to prove Goal''' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg))
Warnings:  Use
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2502

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Goal'''
(implies (and (< (+ (* 2 (/ (+ 2 (- (* 1/3200 n)))))
                    (- (* (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 2 (expt 2 n)
                       (/ (+ 2 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 1)
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:46:25 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>

ACL2 Error in ( defthm b-sum-neg ...):  We do not support the use of
an :INDUCT hint with a :USE hint.  When a subgoal with an :INDUCT hint
arises, we push it for proof by induction.  Upon popping it, we interpret
the :INDUCT hint to determine the induction and we also install any
other non-:USE hints supplied.  On the other hand, when a subgoal with
a :USE hint arises, we augment the formula with the additional hypotheses
supplied by the hint.  If both an :INDUCT and a :USE hint were attached
to the same subgoal we could either add the hypotheses before induction,
which is generally detrimental to a successful induction, or add them
to each of the formulas produced by the induction, which generally
adds the hypotheses in many more places than they are needed.  We therefore
do neither and cause this neat, informative error.  You are encouraged
to attach the :INDUCT hint to the goal or subgoal to which you want
us to apply induction and then attach :USE hints to the individual
subgoals produced, as necessary.  For what it is worth, :INDUCT hints
get along just fine with hints besides :USE.  For example, an :INDUCT
hint and an :IN-THEORY hint would cause an induction and set the post-
induction locally enabled theory to be as specified by the :IN-THEORY.


Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:47:39 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.30 seconds (prove: 0.00, print: 0.00, other: 4.30)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>
*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo hi).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(implies (or (not (integerp hi))
             (not (integerp lo))
             (< hi lo))
         (:p n)).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.
Subgoal *1/
Subgoal *1/'

Splitter note (see :DOC splitter) for Subgoal *1/' (3 subgoals).
  if-intro: ((:definition not))

Subgoal *1/3
Subgoal *1/3'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.1 (Subgoal *1/3') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2
(implies (and (< hi lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/2') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1') is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.1, which we'll try to prove
later.  We therefore regard *1.2 as proved (pending the proof of the
more general *1.1).

Subgoal *1/2 COMPLETED!

We next consider *1.1, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition not)
        (:executable-counterpart not)
        (:induction b-sum))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.08 seconds (prove: 0.07, print: 0.01, other: 0.00)
Prover steps counted:  6184

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:50:17 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.42 seconds (prove: 0.00, print: 0.00, other: 4.42)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  712

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:51:06 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.37 seconds (prove: 0.00, print: 0.00, other: 4.37)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (> h 2))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (> h 2))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1926
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (> h 2))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2805
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo hi).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(implies (or (not (integerp hi))
             (not (integerp lo))
             (< hi lo))
         (:p n)).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.
Subgoal *1/

Splitter note (see :DOC splitter) for Subgoal *1/ (3 subgoals).
  if-intro: ((:definition not))

Subgoal *1/3
Subgoal *1/3'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.1 (Subgoal *1/3') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/2
(implies (and (< hi lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/2') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/1
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1') is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.1, which we'll try to prove
later.  We therefore regard *1.2 as proved (pending the proof of the
more general *1.1).

Subgoal *1/2 COMPLETED!

We next consider *1.1, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

The formula above is subsumed by one of its parents, *1, which we're
in the process of trying to prove by induction.  When an inductive
proof pushes a subgoal for induction that is less general than the
original goal, it may be a sign that either an inappropriate induction
was chosen or that the original goal is insufficiently general.  In
any case, our proof attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition not)
        (:executable-counterpart not)
        (:induction b-sum))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.08 seconds (prove: 0.07, print: 0.00, other: 0.00)
Prover steps counted:  6144

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:56:56 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo hi).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(implies (or (not (integerp hi))
             (not (integerp lo))
             (< hi lo))
         (:p n)).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.
Subgoal *1/

Splitter note (see :DOC splitter) for Subgoal *1/ (3 subgoals).
  if-intro: ((:definition not))

Subgoal *1/3
Subgoal *1/3'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.1 (Subgoal *1/3') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/2
(implies (and (< hi lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/2') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/1
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1') is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.1, which we'll try to prove
later.  We therefore regard *1.2 as proved (pending the proof of the
more general *1.1).

Subgoal *1/2 COMPLETED!

We next consider *1.1, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

The formula above is subsumed by one of its parents, *1, which we're
in the process of trying to prove by induction.  When an inductive
proof pushes a subgoal for induction that is less general than the
original goal, it may be a sign that either an inappropriate induction
was chosen or that the original goal is insufficiently general.  In
any case, our proof attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition not)
        (:executable-counterpart not)
        (:induction b-sum))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.08 seconds (prove: 0.07, print: 0.01, other: 0.00)
Prover steps counted:  6144

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:59:06 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.48 seconds (prove: 0.00, print: 0.00, other: 4.48)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.02, print: 0.00, other: 0.01)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

No induction schemes are suggested by the induction hint.  Consequently,
the proof attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  19

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:59:53 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.39 seconds (prove: 0.00, print: 0.00, other: 4.39)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

No induction schemes are suggested by the induction hint.  Consequently,
the proof attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  19

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:00:26 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.35 seconds (prove: 0.00, print: 0.00, other: 4.35)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.02, print: 0.00, other: 0.01)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>Goal'

([ A key checkpoint:

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1 (Goal') is pushed for proof by induction.

])

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo n).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (or (not (integerp n))
                            (not (integerp lo))
                            (< n lo)))
                   (:p (+ -1 n)))
              (:p n))
     (implies (or (not (integerp n))
                  (not (integerp lo))
                  (< n lo))
              (:p n))).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
four nontautological subgoals.
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/4''
Subgoal *1/4'''
Subgoal *1/4'4'
Subgoal *1/4'5'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/4''
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.1 (Subgoal *1/4'5') is pushed for proof by induction.

])
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

Splitter note (see :DOC splitter) for Subgoal *1/1 (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/1.2
Subgoal *1/1.2'

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/1.2') is pushed for proof by induction.

])
Subgoal *1/1.1

([ A key checkpoint while proving *1 (descended from Goal'):

Subgoal *1/1.1
(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1.1) is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1.1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

The formula above is subsumed by one of its parents, *1, which we're
in the process of trying to prove by induction.  When an inductive
proof pushes a subgoal for induction that is less general than the
original goal, it may be a sign that either an inappropriate induction
was chosen or that the original goal is insufficiently general.  In
any case, our proof attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:induction b-sum)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.16 seconds (prove: 0.15, print: 0.00, other: 0.00)
Prover steps counted:  12105

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal'
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/4''
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:01:25 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.41 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>
*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo n).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (or (not (integerp n))
                            (not (integerp lo))
                            (< n lo)))
                   (:p (+ -1 n)))
              (:p n))
     (implies (or (not (integerp n))
                  (not (integerp lo))
                  (< n lo))
              (:p n))).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.
Subgoal *1/2
Subgoal *1/2'

Splitter note (see :DOC splitter) for Subgoal *1/2' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/2.2
Subgoal *1/2.1
Subgoal *1/2.1'
Subgoal *1/2.1''
Subgoal *1/2.1'''
Subgoal *1/2.1'4'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2.1'
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.1 (Subgoal *1/2.1'4') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

Splitter note (see :DOC splitter) for Subgoal *1/1' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/1.2
Subgoal *1/1.2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/1.2') is pushed for proof by induction.

])
Subgoal *1/1.1

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.1
(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1.1) is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1.1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

No induction schemes are suggested by *1.2.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:induction b-sum)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.17 seconds (prove: 0.16, print: 0.01, other: 0.00)
Prover steps counted:  13433

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoints under a top-level induction ***

Subgoal *1/2.1'
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:04:28 yanpeng] DPLL $ al2
Mono Assembly Linker (al.exe) version 3.0.4.0
Usage: al [options] [sources]
Options: ('/out' must be specified)

  /? or /help               Display this usage message
  @<filename>               Read response file for more options
  /algid:<id>               Algorithm used to hash files (in hexadecimal)
  /base[address]:<addr>     Base address for the library
  /bugreport:<filename>     Create a 'Bug Report' file
  /comp[any]:<text>         Company name
  /config[uration]:<text>   Configuration string
  /copy[right]:<text>       Copyright message
  /c[ulture]:<text>         Supported culture
  /delay[sign][+|-]         Delay sign this assembly
  /descr[iption]:<text>     Description
  /e[vidence]:<filename>    Security evidence file to embed
  /fileversion:<version>    Optional Win32 version (overrides assembly version)
  /flags:<flags>            Assembly flags  (in hexadecimal)
  /fullpaths                Display files using fully-qualified filenames
  /keyf[ile]:<filename>     File containing key to sign the assembly
  /keyn[ame]:<text>         Key container name of key to sign assembly
  /main:<method>            Specifies the method name of the entry point
  /nologo                   Suppress the startup banner and copyright message
  /out:<filename>           Output file name for the assembly manifest
  /prod[uct]:<text>         Product name
  /productv[ersion]:<text>  Product version
  /t[arget]:lib[rary]       Create a library
  /t[arget]:exe             Create a console executable
  /t[arget]:win[exe]        Create a Windows executable
  /template:<filename>      Specifies an assembly to get default options from
  /title:<text>             Title
  /trade[mark]:<text>       Trademark message
  /v[ersion]:<version>      Version (use * to auto-generate remaining numbers)
  /win32icon:<filename>     Use this icon for the output
  /win32res:<filename>      Specifies the Win32 resource file

Sources: (at least one source input is required)
  <filename>[,<targetfile>] add file to assembly
  /embed[resource]:<filename>[,<name>[,Private]]
                            embed the file as a resource in the assembly
  /link[resource]:<filename>[,<name>[,<targetfile>[,Private]]]
                            link the file as a resource to the assembly

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:04:30 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.45 seconds (prove: 0.00, print: 0.00, other: 4.45)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo n).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (or (not (integerp n))
                            (not (integerp lo))
                            (< n lo)))
                   (:p (+ -1 n)))
              (:p n))
     (implies (or (not (integerp n))
                  (not (integerp lo))
                  (< n lo))
              (:p n))).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.
Subgoal *1/2
Subgoal *1/2'

Splitter note (see :DOC splitter) for Subgoal *1/2' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/2.2
Subgoal *1/2.1
Subgoal *1/2.1'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2.1'
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.1 (Subgoal *1/2.1') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

Splitter note (see :DOC splitter) for Subgoal *1/1' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/1.2
Subgoal *1/1.2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/1.2') is pushed for proof by induction.

])
Subgoal *1/1.1

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.1
(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1.1) is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1.1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

No induction schemes are suggested by *1.2.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:induction b-sum)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.14 seconds (prove: 0.13, print: 0.00, other: 0.00)
Prover steps counted:  11284

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoints under a top-level induction ***

Subgoal *1/2.1'
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:13:38 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:13:42 yanpeng] DPLL $ ,s
If ',s' is not a typo you can use command-not-found to lookup the package that contains it, like this:
    cnf ,s

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:13:42 yanpeng] DPLL $ ls
#DPLL_functions.lisp#  DPLL-theorems.lisp  expanded  global.lisp     z3_files
DPLL-functions.lisp    DPLL-todo           foo.lisp  summation.lisp

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:13:43 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.07 seconds (prove: 0.00, print: 0.00, other: 0.07)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.46 seconds (prove: 0.00, print: 0.00, other: 4.46)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo n).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (or (not (integerp n))
                            (not (integerp lo))
                            (< n lo)))
                   (:p (+ -1 n)))
              (:p n))
     (implies (or (not (integerp n))
                  (not (integerp lo))
                  (< n lo))
              (:p n))).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.
Subgoal *1/2
Subgoal *1/2'

Splitter note (see :DOC splitter) for Subgoal *1/2' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/2.2
Subgoal *1/2.1
Subgoal *1/2.1'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2.1'
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.1 (Subgoal *1/2.1') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

Splitter note (see :DOC splitter) for Subgoal *1/1' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/1.2
Subgoal *1/1.2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.2 (Subgoal *1/1.2') is pushed for proof by induction.

])
Subgoal *1/1.1

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.1
(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*1.3 (Subgoal *1/1.1) is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (< n lo) (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1.1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0)).

No induction schemes are suggested by *1.2.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:induction b-sum)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not))
Time:  0.13 seconds (prove: 0.12, print: 0.00, other: 0.00)
Prover steps counted:  11284

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoints under a top-level induction ***

Subgoal *1/2.1'
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(B 4)
-786165731209/2236961860266672
ACL2 !>(B-sum 4)


ACL2 Error in top-level:  b-sum takes 2 arguments but in the call (b-sum 4)
it is given 1 argument.   The formal parameters list for b-sum is 
(h_lo h_hi).

ACL2 !>(B-sum 1 4)
-1176725826168529720866818095/78187436264519887165644800016
ACL2 !>(B-sum 2)


ACL2 Error in top-level:  b-sum takes 2 arguments but in the call (b-sum 2)
it is given 1 argument.   The formal parameters list for b-sum is 
(h_lo h_hi).

ACL2 !>(B 2)
0
ACL2 !>(B 6)
-1176725826168529720866818095/1250998980232318194650316800256
ACL2 !>(B-term 4)
-16/1601
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:52:37 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.30 seconds (prove: 0.00, print: 0.00, other: 4.30)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum h_lo (- n 3)))))))

ACL2 Warning [Free] in ( defthm b-sum-neg-lemma1 ...):  A :rewrite
rule generated from b-sum-neg-lemma1 contains the the free variable
h_lo on the right-hand side of the rule, which is not bound on the
left-hand side or in any hypothesis.  This can cause new variables
to be introduced into the proof, which may surprise you.

Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp n) (< 2 n))
         (equal (b-sum 1 (+ -3 n))
                (b-sum h_lo (+ -3 n))))

*1 (Goal'') is pushed for proof by induction.

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:meta cancel_plus-equal-correct)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription b-sum)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Warnings:  Free
Time:  0.06 seconds (prove: 0.06, print: 0.00, other: 0.00)
Prover steps counted:  5467

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp n) (< 2 n))
         (equal (b-sum 1 (+ -3 n))
                (b-sum h_lo (+ -3 n))))

ACL2 Error in ( defthm b-sum-neg-lemma1 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Free
Time:  0.07 seconds (prove: 0.06, print: 0.00, other: 0.00)
Prover steps counted:  5467

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:53:27 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.28 seconds (prove: 0.00, print: 0.00, other: 4.28)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.05 seconds (prove: 0.04, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :induct (b-sum lo n)
                                 :do-not '(generalize))))

*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo n).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (or (not (integerp n))
                            (not (integerp lo))
                            (< n lo)))
                   (:p (+ -1 n)))
              (:p n))
     (implies (or (not (integerp n))
                  (not (integerp lo))
                  (< n lo))
              (:p n))).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
two nontautological subgoals.
Subgoal *1/2
Subgoal *1/2'

Splitter note (see :DOC splitter) for Subgoal *1/2' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/2.2
Subgoal *1/2.1

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2.1
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.1 (Subgoal *1/2.1) is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

Splitter note (see :DOC splitter) for Subgoal *1/1' (2 subgoals).
  if-intro: ((:definition not))

Subgoal *1/1.2
Subgoal *1/1.2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.2 (Subgoal *1/1.2') is pushed for proof by induction.

])
Subgoal *1/1.1

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1.1
(implies (and (< n lo) (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.3 (Subgoal *1/1.1) is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (< n lo) (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1.1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0)).
Subgoal *1.2/8
Subgoal *1.2/7
Subgoal *1.2/6
Subgoal *1.2/5
Subgoal *1.2/5'
Subgoal *1.2/5''

Splitter note (see :DOC splitter) for Subgoal *1.2/5'' (2 subgoals).
  if-intro: ((:definition b-sum))

Subgoal *1.2/5.2
Subgoal *1.2/5.1
Subgoal *1.2/5.1'

*1.2.1 (Subgoal *1.2/5.1') is pushed for proof by induction.
Subgoal *1.2/4
Subgoal *1.2/4'
Subgoal *1.2/3
Subgoal *1.2/2
Subgoal *1.2/1

So we now return to *1.2.1, which is

(implies (and (< 0 n)
              (< (+ (b-sum 1 (+ -4 n))
                    (- (* 4 (/ (expt 2 (+ -1 n)))))
                    (- (* 1/4
                          (denominator (/ (expt 2 (+ -1 n))))))
                    (* 1/2 (/ (+ 6397/3200 (* 1/3200 n)))
                       (denominator (/ (expt 2 (+ -1 n)))))
                    (* 8 (/ (expt 2 (+ -1 n)))
                       (/ (+ 6403/3200 (- (* 1/3200 n))))))
                 0)
              (integerp n)
              (< 2 n)
              (<= 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -4 n))
               (- (* 4 (/ (expt 2 (+ -1 n)))))
               (- (* 1/4
                     (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
               (- (* 1/8
                     (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
               (* 4 (/ (expt 2 (+ -1 n)))
                  (/ (+ 3201/1600 (- (* 1/3200 n)))))
               (* 8 (/ (expt 2 (+ -1 n)))
                  (/ (+ 6403/3200 (- (* 1/3200 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 n))))))
               (* 1/4 (/ (+ 6397/3200 (* 1/3200 n)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
            (* 2 (/ (expt 2 (+ -1 n)))))).

No induction schemes are suggested by *1.2.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-sum)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:induction b-sum)
        (:induction expt)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-0-+-negative-1)
        (:rewrite associativity-of-*)
        (:rewrite b-sum-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition b-sum) (:definition not))
Time:  0.36 seconds (prove: 0.36, print: 0.00, other: 0.00)
Prover steps counted:  25071

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoints under a top-level induction ***

Subgoal *1/2.1
(implies (and (integerp lo)
              (<= lo n)
              (< (b-sum 1 (+ -3 n)) 0)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Subgoal *1/1.2
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Time:  0.41 seconds (prove: 0.40, print: 0.00, other: 0.01)
Prover steps counted:  27896

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:57:54 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.33 seconds (prove: 0.00, print: 0.00, other: 4.33)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.00, print: 0.01, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(skip-proofs
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :use ((:instance b-term-neg)))))

ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Splitter note (see :DOC splitter) for Goal'' (4 subgoals).
  if-intro: ((:definition fix) (:definition not))

Subgoal 4 ()

([ A key checkpoint:

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Normally we would attempt to prove Subgoal 4 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite associativity-of-+)
        (:rewrite b-sum-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:use b-term-neg))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix) (:definition not))
Warnings:  Use
Time:  0.08 seconds (prove: 0.08, print: 0.00, other: 0.00)
Prover steps counted:  6624

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use
Time:  0.12 seconds (prove: 0.12, print: 0.00, other: 0.00)
Prover steps counted:  9449

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>((good-bye)

)


ACL2 Error in top-level:  Function applications in ACL2 must begin
with a symbol or LAMBDA expression.  ((good-bye)) is not of this form.

ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:59:55 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :use ((:instance b-term-neg)))))

ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Splitter note (see :DOC splitter) for Goal'' (4 subgoals).
  if-intro: ((:definition fix) (:definition not))

Subgoal 4

([ A key checkpoint:

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Normally we would attempt to prove Subgoal 4 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite associativity-of-+)
        (:rewrite b-sum-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:use b-term-neg))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix) (:definition not))
Warnings:  Use
Time:  0.08 seconds (prove: 0.08, print: 0.00, other: 0.00)
Prover steps counted:  6624

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use
Time:  0.13 seconds (prove: 0.12, print: 0.00, other: 0.01)
Prover steps counted:  9449

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[18:01:14 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.38 seconds (prove: 0.00, print: 0.00, other: 4.38)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
***********************************************
************ ABORTING from raw Lisp ***********
Error:  Unexpected end of file on #<BASIC-FILE-CHARACTER-INPUT-STREAM ("/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/foo.lisp"/5 ISO-8859-1) #x302002550CED>, near position 2722
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
 (:stop-ld 1)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[18:01:47 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.07 seconds (prove: 0.00, print: 0.00, other: 0.07)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.36 seconds (prove: 0.00, print: 0.00, other: 4.36)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.00, print: 0.00, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :use ((:instance b-term-neg (h n))))))

ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''
Goal'''

([ A key checkpoint:

Goal'''
(implies (and (< (+ (* 2 (/ (+ 2 (- (* 1/3200 n)))))
                    (- (* (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 2 (expt 2 n)
                       (/ (+ 2 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 1)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Normally we would attempt to prove Goal''' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-right)
        (:rewrite associativity-of-*)
        (:rewrite b-sum-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg))
Warnings:  Use
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  3489

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Goal'''
(implies (and (< (+ (* 2 (/ (+ 2 (- (* 1/3200 n)))))
                    (- (* (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 2 (expt 2 n)
                       (/ (+ 2 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 1)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use
Time:  0.09 seconds (prove: 0.08, print: 0.00, other: 0.01)
Prover steps counted:  6314

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:26:41 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.01)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(local (defthm b-sum-neg-lemma2
                        (implies (and (integerp n)
                                      (> n 2)
                                      (b-sum 1 (- n 3)))
                                 (< (+ (b-term (- n 2))
                                       (b-term (- 2 n))
                                       (b-sum 1 (- n 3)))
                                    0))))

ACL2 Warning [Non-rec] in ( defthm b-sum-neg-lemma2 ...):  A :rewrite
rule generated from b-sum-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp n)
              (< 2 n)
              (b-sum 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 n).  This
suggestion was produced using the :induction rule expt.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip n))
                   (not (= (fix 2) 0))
                   (<= n 0)
                   (:p (+ n 1)))
              (:p n))
     (implies (and (not (zip n))
                   (not (= (fix 2) 0))
                   (< 0 n)
                   (:p (+ n -1)))
              (:p n))
     (implies (and (not (zip n)) (= (fix 2) 0))
              (:p n))
     (implies (zip n) (:p n))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
ten nontautological subgoals.
Subgoal *1/10
Subgoal *1/9
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/6'
Subgoal *1/6''

Splitter note (see :DOC splitter) for Subgoal *1/6'' (2 subgoals).
  if-intro: ((:definition b-sum))

Subgoal *1/6.2
Subgoal *1/6.1
Subgoal *1/6.1'
Subgoal *1/6.1''
Subgoal *1/6.1'''
Subgoal *1/6.1'4'
Subgoal *1/6.1'5'
Subgoal *1/6.1'6'
Subgoal *1/6.1'7'
Subgoal *1/6.1'8'
Subgoal *1/6.1'9'
Subgoal *1/6.1'10'
Subgoal *1/6.1'11'
Subgoal *1/6.1'12'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/6.1'
(implies (and (< 0 n)
              (< (+ (b-sum 1 (+ -4 n))
                    (- (* 4 (/ (expt 2 (+ -1 n)))))
                    (- (* 1/4
                          (denominator (/ (expt 2 (+ -1 n))))))
                    (* 1/2 (/ (+ 6397/3200 (* 1/3200 n)))
                       (denominator (/ (expt 2 (+ -1 n)))))
                    (* 8 (/ (expt 2 (+ -1 n)))
                       (/ (+ 6403/3200 (- (* 1/3200 n))))))
                 0)
              (integerp n)
              (< 2 n)
              (<= 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -4 n))
               (- (* 4 (/ (expt 2 (+ -1 n)))))
               (- (* 1/4
                     (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
               (- (* 1/8
                     (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
               (* 4 (/ (expt 2 (+ -1 n)))
                  (/ (+ 3201/1600 (- (* 1/3200 n)))))
               (* 8 (/ (expt 2 (+ -1 n)))
                  (/ (+ 6403/3200 (- (* 1/3200 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 n))))))
               (* 1/4 (/ (+ 6397/3200 (* 1/3200 n)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
            (* 2 (/ (expt 2 (+ -1 n))))))

*1.1 (Subgoal *1/6.1'12') is pushed for proof by induction.

])
Subgoal *1/5
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp r6)
              (rationalp r5)
              (< r5 0)
              (rationalp r3)
              (< 0 r3)
              (rationalp r0)
              (< 0 r0)
              (rationalp r1)
              (< 0 r1)
              (rationalp s)
              (< s 0)
              (rationalp k)
              (< 0 k)
              (acl2-numberp bsm)
              (integerp l)
              (< 0 l)
              (rationalp r)
              (< 0 r)
              (integerp j)
              (< 0 j)
              (< 0 n)
              (< (+ bsm r5 r6 (- (* 1/4 (denominator r1)))
                    (* 1/2 r0 (denominator r1)))
                 0)
              (integerp n)
              (< 2 n)
              (<= 1 (+ -3 n)))
         (< (+ bsm r5
               r6 (- (* 1/4 (denominator (* 1/2 r1))))
               (- (* 1/8 (denominator (* 1/2 r1))))
               (* 1/4 r0 (denominator (* 1/2 r1)))
               (* 4 r1 (/ (+ 3201/1600 s)))
               (* 1/2 (/ (+ 3199/1600 r))
                  (denominator (* 1/2 r1))))
            (* 2 r1))).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg-lemma2 ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-sum)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription b-sum)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition b-sum))
Warnings:  Non-rec
Time:  0.53 seconds (prove: 0.53, print: 0.00, other: 0.00)
Prover steps counted:  23877

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp n)
              (< 2 n)
              (b-sum 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/6.1'
(implies (and (< 0 n)
              (< (+ (b-sum 1 (+ -4 n))
                    (- (* 4 (/ (expt 2 (+ -1 n)))))
                    (- (* 1/4
                          (denominator (/ (expt 2 (+ -1 n))))))
                    (* 1/2 (/ (+ 6397/3200 (* 1/3200 n)))
                       (denominator (/ (expt 2 (+ -1 n)))))
                    (* 8 (/ (expt 2 (+ -1 n)))
                       (/ (+ 6403/3200 (- (* 1/3200 n))))))
                 0)
              (integerp n)
              (< 2 n)
              (<= 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -4 n))
               (- (* 4 (/ (expt 2 (+ -1 n)))))
               (- (* 1/4
                     (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
               (- (* 1/8
                     (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
               (* 4 (/ (expt 2 (+ -1 n)))
                  (/ (+ 3201/1600 (- (* 1/3200 n)))))
               (* 8 (/ (expt 2 (+ -1 n)))
                  (/ (+ 6403/3200 (- (* 1/3200 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 n))))))
               (* 1/4 (/ (+ 6397/3200 (* 1/3200 n)))
                  (denominator (* 1/2 (/ (expt 2 (+ -1 n)))))))
            (* 2 (/ (expt 2 (+ -1 n))))))

ACL2 Error in ( defthm b-sum-neg-lemma2 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Non-rec
Time:  0.58 seconds (prove: 0.57, print: 0.00, other: 0.00)
Prover steps counted:  26702

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:27:44 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.35 seconds (prove: 0.00, print: 0.00, other: 4.35)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(local (defthm b-sum-neg-lemma2
                        (implies (and (integerp n)
                                      (> n 2)
                                      (b-sum 1 (- n 3)))
                                 (< (+ (b-term (- n 2))
                                       (b-term (- 2 n))
                                       (b-sum 1 (- n 3)))
                                    0))
                        :hints (("Goal" :use ((:instance b-term-neg))))))

ACL2 Warning [Non-rec] in ( defthm b-sum-neg-lemma2 ...):  A :rewrite
rule generated from b-sum-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-sum-neg-lemma2 ...):  It is unusual
to :USE an enabled :REWRITE or :DEFINITION rule, so you may want to
consider disabling (:rewrite b-term-neg) in the hint provided for Goal.
See :DOC using-enabled-rules.

Goal'
Goal''

Splitter note (see :DOC splitter) for Goal'' (4 subgoals).
  if-intro: ((:definition fix) (:definition not))

Subgoal 4

([ A key checkpoint:

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n)
              (b-sum 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Normally we would attempt to prove Subgoal 4 by induction.  However,
we prefer in this instance to focus on the original(good-bye) input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg-lemma2 ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite associativity-of-+)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:use b-term-neg))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix) (:definition not))
Warnings:  Use and Non-rec
Time:  0.12 seconds (prove: 0.12, print: 0.00, other: 0.00)
Prover steps counted:  9826

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 4
(implies (and (not (integerp h))
              (integerp n)
              (< 2 n)
              (b-sum 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg-lemma2 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use and Non-rec
Time:  0.16 seconds (prove: 0.15, print: 0.00, other: 0.01)
Prover steps counted:  12651

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>we prefer in this instance to focus on the original(good-bye) input conjecture


ACL2 Error in top-level:  Global variables, such as we, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as prefer, are not
allowed. See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as in, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as this, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as instance, are not
allowed. See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as to, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as focus, are not
allowed. See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as on, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as the, are not allowed.
See :DOC ASSIGN and :DOC @.

ACL2 !>

ACL2 Error in top-level:  Global variables, such as original, are not
allowed. See :DOC ASSIGN and :DOC @.

ACL2 !>

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:29:08 yanpeng] DPLL $ If 'nput' is not a typo you can use command-not-found to lookup the package that contains it, like this:
    cnf nput

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:29:08 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.29 seconds (prove: 0.00, print: 0.00, other: 4.29)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the three encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(local
           (defthm
                b-sum-neg-lemma2
                (implies (and (integerp n)
                              (> n 2)
                              (b-sum 1 (- n 3)))
                         (< (+ (b-term (- n 2))
                               (b-term (- 2 n))
                               (b-sum 1 (- n 3)))
                            0))
                :hints (("Goal" :use ((:instance b-term-neg (h (- n 2))))))))

ACL2 Warning [Non-rec] in ( defthm b-sum-neg-lemma2 ...):  A :rewrite
rule generated from b-sum-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-sum-neg-lemma2 ...):  It is unusual
to :USE an enabled :REWRITE or :DEFINITION rule, so you may want to
consider disabling (:rewrite b-term-neg) in the hint provided for Goal.
See :DOC using-enabled-rules.

Goal'
Goal''
Goal'''

([ A key checkpoint:

Goal'''
(implies (and (< (+ (* 8 (/ (+ 3201/1600 (- (* 1/3200 n)))))
                    (- (* 1/4 (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 1/2 (expt 2 n)
                       (/ (+ 3199/1600 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 4)
              (integerp n)
              (< 2 n)
              (b-sum 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Normally we would attempt to prove Goal''' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg-lemma2 ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-*-/-right)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Hint-events: ((:use b-term-neg))
Warnings:  Use and Non-rec
Time:  0.06 seconds (prove: 0.06, print: 0.00, other: 0.00)
Prover steps counted:  5082

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Goal'''
(implies (and (< (+ (* 8 (/ (+ 3201/1600 (- (* 1/3200 n)))))
                    (- (* 1/4 (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 1/2 (expt 2 n)
                       (/ (+ 3199/1600 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 4)
              (integerp n)
              (< 2 n)
              (b-sum 1 (+ -3 n)))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg-lemma2 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use and Non-rec
Time:  0.10 seconds (prove: 0.10, print: 0.00, other: 0.01)
Prover steps counted:  7907

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:29:45 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.32 seconds (prove: 0.00, print: 0.00, other: 4.32)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.03 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :use ((:instance b-term-neg (h (- n 2)))))))

ACL2 Warning [Use] in ( defthm b-sum-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''
Goal'''

([ A key checkpoint:

Goal'''
(implies (and (< (+ (* 8 (/ (+ 3201/1600 (- (* 1/3200 n)))))
                    (- (* 1/4 (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 1/2 (expt 2 n)
                       (/ (+ 3199/1600 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 4)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

Normally we would attempt to prove Goal''' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:definition b-term)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /-cancellation-on-left)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-*-/-right)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite b-sum-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Hint-events: ((:use b-term-neg))
Warnings:  Use
Time:  0.05 seconds (prove: 0.05, print: 0.00, other: 0.00)
Prover steps counted:  3752

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Goal'''
(implies (and (< (+ (* 8 (/ (+ 3201/1600 (- (* 1/3200 n)))))
                    (- (* 1/4 (expt 2 n)
                          (denominator (/ (expt 2 n)))))
                    (* 1/2 (expt 2 n)
                       (/ (+ 3199/1600 (* 1/3200 n)))
                       (denominator (/ (expt 2 n)))))
                 4)
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use
Time:  0.09 seconds (prove: 0.08, print: 0.00, other: 0.01)
Prover steps counted:  6577

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:32:38 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.40 seconds (prove: 0.00, print: 0.00, other: 4.40)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1

(good-bye)
ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :use ((:induct (b-sum lo (- n 2)))))))


ACL2 Error in ( defthm b-sum-neg ...):  The object 
(:induct (b-sum lo (- n 2))) is an ill-formed lemma instance because
is not a symbol, a rune in the current logical world, or a list whose
first element is :THEOREM, :INSTANCE, or :FUNCTIONAL-INSTANCE.  See
:DOC lemma-instance.


Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:33:22 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.41 seconds (prove: 0.00, print: 0.00, other: 0.41)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.55 seconds (prove: 0.00, print: 0.00, other: 4.55)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.01, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.02)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
       (good-bye) (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :induct (b-sum lo (- n 2)))))

*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

No induction schemes are suggested by the induction hint.  Consequently,
the proof attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: nil
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  2825

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>       (good-bye) (:type-prescription expt-type-prescription-integerp)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:34:36 yanpeng] DPLL $ bash: syntax error near unexpected token `)'

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:34:36 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.45 seconds (prove: 0.00, print: 0.00, other: 0.45)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.58 seconds (prove: 0.00, print: 0.00, other: 4.58)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (skip-proofs
           (defthm
             b-term-neg-lemma3
             (implies (and (integerp h) (>= h 1))
                      (< (+ (* (b-term-expt h) (b-term-rest h))
                            (* (b-term-expt (- h))
                               (b-term-rest (- h))))
                         0))
             :hints
             (("Goal" :clause-processor
                      (my-clause-processor
                           clause
                           '((:expand (b-term-rest gamma mu equ-c))
                             (:python-file "B-term-neg")
                             (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                    (expt_gamma_minus_h (b-term-expt (- h))
                                                        rationalp)))
                             (:hypothesize ((< expt_gamma_h 1)
                                            (> expt_gamma_h 0)
                                            (< expt_gamma_minus_h 1)
                                            (> expt_gamma_minus_h 0))))))))))

ACL2 Warning [Skip-proofs] in ( ENCAPSULATE NIL (local ...) ...): 
ACL2 has encountered a SKIP-PROOFS form, 
(skip-proofs
   (defthm
        b-term-neg-lemma3
        (implies (and (integerp h) (>= h 1))
                 (< (+ # #) 0))
        :hints (("Goal" :clause-processor (my-clause-processor clause #))))),
in the context of a book or an encapsulate event.  Therefore, no logical
claims may be soundly made in this context.  See :DOC SKIP-PROOFS.
(See :DOC set-iprint to be able to see elided values in this message.)


ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

b-term-neg-lemma3


ACL2 !>>>(defthm b-term-neg
                 (implies (and (integerp h) (>= h 1))
                          (< (+ (b-term h) (b-term (- h))) 0))
                 :hints (("Goal" :use ((:instance b-term-neg-lemma1)
                                       (:instance b-term-neg-lemma2)
                                       (:instance b-term-neg-lemma3)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg ...):  A :rewrite rule
generated from b-term-neg will be triggered only by terms containing
the non-recursive function symbol b-term.  Unless this function is
disabled, this rule is unlikely ever to be used.


ACL2 Warning [Use] in ( defthm b-term-neg ...):  It is unusual to :USE
an enabled :REWRITE or :DEFINITION rule, so you may want to consider
disabling (:rewrite b-term-neg-lemma1), (:rewrite b-term-neg-lemma2)
and (:rewrite b-term-neg-lemma3) in the hint provided for Goal.  See
:DOC using-enabled-rules.

Goal'
Goal''

Q.E.D.

Summary
Form:  ( defthm b-term-neg ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite b-term-neg-lemma1)
        (:rewrite b-term-neg-lemma2)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:use b-term-neg-lemma1)
              (:use b-term-neg-lemma2)
              (:use b-term-neg-lemma3))
Warnings:  Use and Non-rec
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  1931
b-term-neg

End of Encapsulated Events.

Having verified that the encapsulated events validate the signatures
of the ENCAPSULATE event, we discard the ephemeral theory and extend
the original theory as directed by the signatures and the non-LOCAL
events.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Use, Skip-proofs, Subsume and Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2810
 t
ACL2 !>>
To verify that the two encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-sum-neg-lemma1
                        (implies (and (integerp n) (> n 2))
                                 (equal (b-sum 1 (- n 2))
                                        (+ (b-term (- n 2))
                                           (b-term (- 2 n))
                                           (b-sum 1 (- n 3)))))))
Goal'

Q.E.D.

Summary
Form:  ( defthm b-sum-neg-lemma1 ...)
Rules: ((:definition b-sum)
        (:definition b-term)
        (:definition fix)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite associativity-of-*)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|))
Time:  0.03 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  2825
b-sum-neg-lemma1


ACL2 !>>>(defthm b-sum-neg
                 (implies (and (integerp n) (> n 2))
                          (< (b-sum 1 (- n 2)) 0))
                 :hints (("Goal" :induct (b-sum lo hi))))

*1 (the initial Goal, a key checkpoint) is pushed for proof by induction.

We have been told to use induction.  One induction scheme is suggested
by the induction hint.  

We will induct according to a scheme suggested by (b-sum lo hi).  This
suggestion was produced using the :induction rule b-sum.  If we let
(:p n) denote *1 above then the induction scheme we'll use is
(implies (or (not (integerp hi))
             (not (integerp lo))
             (< hi lo))
         (:p n)).
This induction is justified by the same argument used to admit b-sum.
When applied to the goal at hand the above induction scheme produces
one nontautological subgoal.
Subgoal *1/
Subgoal *1/'

Splitter note (see :DOC splitter) for Subgoal *1/' (3 subgoals).
  if-intro: ((:definition not))

Subgoal *1/3
Subgoal *1/3'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.1 (Subgoal *1/3') is pushed for proof by induction.

])
Subgoal *1/2
Subgoal *1/2'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/2
(implies (and (< hi lo) (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.2 (Subgoal *1/2') is pushed for proof by induction.

])
Subgoal *1/1
Subgoal *1/1'

([ A key checkpoint while proving *1 (descended from Goal):

Subgoal *1/1
(implies (and (not (integerp lo))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

*1.3 (Subgoal *1/1') is pushed for proof by induction.

])

So we now return to *1.3, which is

(implies (and (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0)).

But the formula above is subsumed by *1.2, which we'll try to prove
later.  We therefore regard *1.3 as proved (pending the proof of the
more general *1.2).

Subgoal *1/1 COMPLETED!

We next consider *1.2, which is

(implies (and (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0)).

But the formula above is subsumed by *1.1, which we'll try to prove
later.  We therefore regard *1.2 as proved (pending the proof of the
more general *1.1).

Subgoal *1/2 COMPLETED!

We next consider *1.1, which is

(implies (and (integerp n) (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0)).
Subgoal *1.1/8
Subgoal *1.1/7
Subgoal *1.1/6
Subgoal *1.1/5
Subgoal *1.1/5'
Subgoal *1.1/5''

Splitter note (see :DOC splitter) for Subgoal *1.1/5'' (2 subgoals).
  if-intro: ((:definition b-sum))

Subgoal *1.1/5.2
Subgoal *1.1/5.1
Subgoal *1.1/5.1'
Subgoal *1.1/5.1''
Subgoal *1.1/5.1'''
Subgoal *1.1/5.1'4'
Subgoal *1.1/5.1'5'
Subgoal *1.1/5.1'6'
Subgoal *1.1/5.1'7'
Subgoal *1.1/5.1'8'
Subgoal *1.1/5.1'9'
Subgoal *1.1/5.1'10'
Subgoal *1.1/5.1'11'
Subgoal *1.1/5.1'12'

*1.1.1 (Subgoal *1.1/5.1'12') is pushed for proof by induction.
Subgoal *1.1/4
Subgoal *1.1/4'
Subgoal *1.1/3
Subgoal *1.1/2
Subgoal *1.1/1

So we now return to *1.1.1, which is

(implies (and (rationalp r6)
              (rationalp r5)
              (< r5 0)
              (rationalp r3)
              (< 0 r3)
              (rationalp r0)
              (< 0 r0)
              (rationalp r1)
              (< 0 r1)
              (rationalp s)
              (< s 0)
              (rationalp k)
              (< 0 k)
              (acl2-numberp bsm)
              (integerp l)
              (< 0 l)
              (rationalp r)
              (< 0 r)
              (integerp j)
              (< 0 j)
              (< 0 n)
              (< (+ bsm r5 r6 (- (* 1/4 (denominator r1)))
                    (* 1/2 r0 (denominator r1)))
                 0)
              (integerp n)
              (< 2 n)
              (<= 1 (+ -3 n)))
         (< (+ bsm r5
               r6 (- (* 1/4 (denominator (* 1/2 r1))))
               (- (* 1/8 (denominator (* 1/2 r1))))
               (* 1/4 r0 (denominator (* 1/2 r1)))
               (* 4 r1 (/ (+ 3201/1600 s)))
               (* 1/2 (/ (+ 3199/1600 r))
                  (denominator (* 1/2 r1))))
            (* 2 r1))).

No induction schemes are suggested by *1.1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-sum-neg ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-sum)
        (:definition b-term)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition signum)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart b-sum)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart denominator)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction b-sum)
        (:induction expt)
        (:rewrite /r-when-abs-numerator=1)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-*)
        (:rewrite b-sum-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite exponents-add)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite numerator-/x)
        (:type-prescription b-sum)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription |x < y  =>  0 < -x+y|)
        (:type-prescription |x < y  =>  0 < y-x|))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition b-sum) (:definition not))
Time:  0.60 seconds (prove: 0.59, print: 0.01, other: 0.00)
Prover steps counted:  29726

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal
(implies (and (integerp n) (< 2 n))
         (< (b-sum 1 (+ -2 n)) 0))

*** Key checkpoint under a top-level induction ***

Subgoal *1/3
(implies (and (not (integerp hi))
              (integerp n)
              (< 2 n))
         (< (+ (b-sum 1 (+ -3 n))
               (- (* 4 (/ (expt 2 n))))
               (- (* 1/4 (denominator (/ (expt 2 n)))))
               (* 1/2 (/ (+ 3199/1600 (* 1/3200 n)))
                  (denominator (/ (expt 2 n))))
               (* 8 (/ (expt 2 n))
                  (/ (+ 3201/1600 (- (* 1/3200 n))))))
            0))

ACL2 Error in ( defthm b-sum-neg ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Time:  0.64 seconds (prove: 0.62, print: 0.01, other: 0.01)
Prover steps counted:  32551

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[16:42:58 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.42 seconds (prove: 0.00, print: 0.00, other: 0.42)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.42 seconds (prove: 0.00, print: 0.00, other: 4.42)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

Original clause(connect): (implies
                           (if (integerp h) (not (< h '1)) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1)
                                (not (< h '1))
                                'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (binary-*
               expt_gamma_h
               ((lambda
                 (|var0|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                h))
              (binary-*
               expt_gamma_minus_h
               ((lambda
                 (|var1|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                (unary-- h))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1)
                                       (not (< h '1))
                                       'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (binary-*
                      expt_gamma_h
                      ((lambda
                        (|var0|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       h))
                     (binary-*
                      expt_gamma_minus_h
                      ((lambda
                        (|var1|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       (unary-- h))))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 1.09 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if (if (rationalp expt_gamma_minus_h)
                                        (if (rationalp expt_gamma_h)
                                            (integerp h)
                                            'nil)
                                        'nil)
                                    (if (< '0 expt_gamma_minus_h)
                                        (if (< expt_gamma_minus_h '1)
                                            (if (< '0 expt_gamma_h)
                                                (if (< expt_gamma_h '1)
                                                    (not (< h '1))
                                                    'nil)
                                                'nil)
                                            'nil)
                                        'nil)
                                    'nil)
                                (<
                                 (binary-+
                                  (binary-*
                                   expt_gamma_h
                                   ((lambda
                                     (|var0|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    h))
                                  (binary-*
                                   expt_gamma_minus_h
                                   ((lambda
                                     (|var1|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    (unary-- h))))
                                 '0)))
                              (b-term-expt h)
                              (b-term-expt (unary-- h))
                              h))
                            (implies
                             (if (integerp h) (not (< h '1)) 'nil)
                             (<
                              (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0)))
                           (implies
                                (if (integerp h)
                                    (if (equal expt_gamma_h (b-term-expt h))
                                        (not (< h '1))
                                        'nil)
                                    'nil)
                                (rationalp expt_gamma_h))
                           (implies (if (integerp h)
                                        (if (equal expt_gamma_minus_h
                                                   (b-term-expt (unary-- h)))
                                            (not (< h '1))
                                            'nil)
                                        'nil)
                                    (rationalp expt_gamma_minus_h)))

 Success!
Subgoal 3
Subgoal 3'
Subgoal 3''

([ A key checkpoint:

Subgoal 3''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

Normally we would attempt to prove Subgoal 3'' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg-lemma3 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-left)
        (:rewrite <-unary-/-positive-right)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite times-zero)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1751

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 3''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

ACL2 Error in ( defthm b-term-neg-lemma3 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.06 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2630

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(B 1000000)
  C-c C-c
***********************************************
************ ABORTING from raw Lisp ***********
Error:  interrupt signal
***********************************************

The message above might explain the error.  If not, and
if you didn't cause an explicit interrupt (Control-C),
then the root cause may be call of a :program mode
function that has the wrong guard specified, or even no
guard specified (i.e., an implicit guard of t).
See :DOC guards.

To enable breaks into the debugger (also see :DOC acl2-customization):
(SET-DEBUGGER-ENABLE T)
ACL2 !>(B 1000)
-15981623293355002756022751410378084146686967126874575026668256249888728406385009227407889150143951663582684202112114149517422776896302685710690147846212709622468348926269812087578205937174387255406848178628474732751444591607997372930575062304925643507375683588331403383093171523440922150551106382313381171023498959558677196478800167909577823445289407836506844824798053664057269429914376392691583561086439961224964847142588737467836534413014085060271478590022096737255176397641557012384907526286737863247792270858313067763390530956421051251772728326840443752021444538060559040335281506816911473938745536779708028026118893344183161775472340686099502904018628697982983432282811530815069351345015948615382210225328187878441771337715107752955711517788731491280974777899704365081849986573555379245894898960808369960104202792564971412183093023885635916047599461892341068694323989763106991417844332079212220573092083672217480391490969005044258274568756365950912342543155244323137579916890667112942256706763093992011231248168226717255559087762924476256633458946106930430173077083835717977819131418737123869964481531805697255175283373529809025575130760750707017077605367817206575538709865930408562017010296659970439428327323550400574165215164605393220325491579357080704127874690253432294708687591027360927508957739601019983199688487237387685325281609782377652237049732944597675227758757533305936720715854537965506809938318722330947396161364866668493477018356357007976720417197493529564685115448805121238910211832268828945903747501851625072494379328267833172292994664283273912069525899156536441508791599328385086808542696939284099353119322816122333921308135056553637502590804316863956656329431663592019446415569728333882434761236514183003062899269320031641687052304821286491625705789651279920795126632026543486480807933515300361942958327397549313649697814811845970594006958476298111838056663226337979691286971982577035591724732235886263712399340476536930231992467228214042670854472282680637275878121980487236965480428281713816392763576642926572735402034883076128375246729215019254711809266195487753654602177158757549534181893407166461934575468513591928442737543201675233425443776403291515535960891095225317280614415334337224037492912186136643784397439633059238008343944160367729797754987147652276831038426939312084923227760160261117421207402319225011235675158205048602760863102242334183129322417905930037082649325465740732312710350908424644809889746118378209728214645462607041792791048248158425262636339426648748405307056352105886205874723018015440148567912016386637142120775016217235330158384542946490161780942583311761996023219364134672101821084250019791747024814306176068211312806924428938772333931942324149630079661780038071338032382671218321374335840864900870469933827309024187674040698957854726432613139403591248929434966892337588896866877167892125439859902543885410720936027363518949556855332329182166166670880567362252408359783496696989453739802091789202137450135950953214188887/59285905341288037947774065029323146045253176498112636749373977043153069366339196738453409994013866757635436789917159614645689053895886756850801445822053392350780792075268120537480445276352537262407908229324391266419506864614401675901660287003667655861229410095103694210444743833168050423149690980366532374131486580715143943872955272729520862409918922562395726253423593913830269190075419696239334574413597175692359622228659883392541133946144847686204445321472701634886993719283583771621825015217333943335539212893294829888446173116693599802323177463947025257960622084965221803875305181763849045841920245959879823058405842030248631782649991173774041612714401724443547616989289412457778033010460277230160473970364712729160985295020003111332989712084856246635806748387680330281891113441795413785527514012399065852177054122473447333773642113800162439448387478136992626886577236850988153020899540963791884528462661046338294200176574257075020700455369557728093206527629784184721507744002442575697799064691632287333504906266158306414510388749159109588582693425894655352687931267442747508778163690384001139064876989054963390053314149447414280660875674502626945494749010847337259983083037424781081616125800356202988604158533911821017330701948583340725520437037640360810982729985681283784816142935297248628160170603213399892394121347709226485801248661878244592159961094250132786587776566705712142588060177740487548906280920566000418967736607663283365262424017123156799945304178502040320777945483059018543780753113421349890354889301025135398608807113576242630138679533156358312410097241166675237534563383233927917074626597118836134453101939512079956697451782124354026962534600904064487261262627355032691876646466158548768936923432119757349238766720329369393568006569049589706362000880299976404624993070811820466417166826709338924544443082108391309097948018558152654899301890895318602675098795652129437045733277514154066027621920900911438698860921775931488399692819067787521272528239297700137894055630162940185616212332046402623799473228647640275064742988143421717855981478381523325449971040287254815167373268206824323647807308964874011671703707121355540455210759552004615597728142171674385882379948256656982485754627055836521277932298236074574260660205179408445013694747778884557061340401829341353562626338367453322148311473314419514490160093172942508198048568846699719258067974393720383424315509790738043641632038053833017919020940262867395809045188468642351521328087460268487370549576838415710708728778270894861341549735554572135096082476177511042238733384282380697010205369872738753070656813555046325477965772776263841996423843421749895589444272526646216667503527325599839713374695330617783570475508802283136590192996322087180809794196280463827072642987693729919742081912032527139785853761202902647734857789599140287479364141003829444093618423068787383132435769829313130477889975483676701057957472270070464795470555700966431683815289673732735733676369520993345498072996612818337792000
ACL2 !>(B 4000)
-68972706606422383381573136804560588580148070817306270426899336401634831717460384788583752357661659193558118938728364366857171881088939785793020120067113506292820777288159484247402436482405553667673196109261936757917926907276668960207004112178923440936921224221971733520808155545395108668302604956219207895570446118099833347455410276852667576709445296694329820821126731093622891858071613375473001143500092384775314211024976243422682598030281255610418329651027016882501584525751605242884861640049040207002654550556941953735639676026234405684355967648294744687862981275041415297006691955863184762662282185695843489146713525078580557569189634554869055605475033198628711393499501020534995587824190472478075191411607729539233288380933371144210203080501143691237702872580598957126598225624114550638017204073297560090534969495407409182561175773345112902575680355496133006772299228596675507030425378093275151781669712384435688702119922286472350142423085456986429441847551194198964740094827741457803534381226602685818568987665632471317857677424961186522240640170854381097607598400507189745641148727457430699549706166468308246739800778889565296754563143322948691379374544272760221985418788920357251643779367384752533912612810286653822837588828916938642434011610666129569792408712445927192782824031839543808702093158485063411933928863742183047257112690222010707678004861678456499060414931772924958073424722881365939336165743883867775609829392611128794676718992150524775215165064702208197168413551063139616850239094300199171514629917950298329611571267834353095266983635015344061458631354299465232627090266399245272539373625610006308704630105625725533381423037343320155941998733897887693872519429450056235927699092779577179763800086988156671122320606620952458438678265039488122027603750279081479373188682406336428740260774408813468526143894218664542986236051508800454932114749947059424582240428979491738045297241803814290057352848957648331503290125164235998687651610046188437984556324217336515325913976125036175270230385878101487034659899741856740594497206461983575792328987923528256607188115716310866582103848550690920991291440477203720880669311779596710715092494908491466692990192044569742387040223854312498568134716817866208133263906986316224939164924157694669713982971811148679759612905439078191662133181276836785976126477756566014035628267318201575810827724561173273980628945387277784378507055186736859707074809252493677950396245655996515613227838112118131461566446499442812092085179633303494106662633353059735570341484786714204066497850877366981562851154932583011975042364293346576319174578108570474179430122018305466953707989021017182348907747730937489411734115853475693898288456321859159045769009826047665279948226401326000588493473160038004512977591067052511052017614682404639924791363558684505534203197772844604565773259174074387878324918340225719750414043588407974644884727723840798374322034514818775310921060281469261824725872834519709300209690878674759040588924200457033439959922598244326675708258412428510603366502270154595162090582441659469249515253049339442921315131885702311946884146199420504594539818357970849080301080613697931661622595849866692741892620584440410804834688890492848468614964655875194789161643390673300868240769151983767840184942415669020955586355357064715281279981978086132434109808644044635246199832614064801348774004965234508822643640553498450112938351203057676415053739748386794694087782474796327971459071369859795391843471188928626830613469790248233113592841409280864255115427366236830691072431308041787072606747998698985970509332192387660853114605543447221770128691452038911865575622082262751797259034917496267500144401060813838595479822795264803818936068190413213663393332258858909427433381007951054426375596542777144208337947292818099238019122419427098518688506386125732924023569036244406699943894722196399112279069878183490949814480252957906717831421480308241710607478931841590659577595888337257640631134330688266559568607698763451731437157377595262721146340024673401227583487290455444866043608633298640395948419055705999328772429450707414488397764830138399122188187439877496538932375257950264377097267639099350878861505556548337797216716984350739237633031043658761033779553957230308204985566675300875557170019470140165574734616140051215839581302362756947972946014889861060566969858210510878220593821239659977262295037325947411616691443432498167179167299512886541831154835810654268782160602591233603345761750939319103293343054586918265614029346690022774752572708382959043386627949654942135257024816281708194107974689271990305917144754917606201859060547683329306661262431745798382150028508400460816369650504507309425003245528007885372904595251709819464233632223588698647664734874601015620000025284709382338176968164825635019555886634250153627793858202281991948182938604263288944451443457558711144636625488148086533469542027677302675543104628050293522747978506855340540351147674099200592950751416203125492482027822231181764629657509145609962919219305967711759367459563515322132921115866951519514231070502416401817336177556073314863343235404681372559979282610822950325662709301617234594939423159017479935099593019576435958226170971943772059752654698786877276937320829452274010746185399137338820538252349013655765887669053311772948718096905977312436171574336218116733477694946193523834081507763818686852013001611739306181204167702694845645361461995043484872357912264552654960040308781401131472014450540948227684288359186747580781857925073659287334321949595875522837638467273040920536653820831392715823754175923421421683143455481454670987945943541074275721364086384840903626228639979908514056626672964265496743215564918310096853517152480512743506665509607671187699298664152363081572663941509284520012661758925852111668294146843389144510947968093118198194495264301435790544940576173377235285842039369730970667853814185195601140524766861040449323551716205883869194592513611671882268758074342285829470861904451043502793257748167272048108433740494767956129738833102264241958679281533008235778231830957267612392202799437192249912892543908406172884039866536631141109579006548661659418839831804362246203609169800707216680513102038894877716319025991511332177216412937090985948805441660240390166737331300300606661726645295182929446708708280666871413012822694008935757787056466037945138378373718415773078852341755603699000659080970912571264111143698675277997981455369062931591516760926539880497569771607544266607009535973256398711954886072471243195131101319925524615431778030433872618329682432985819599144271030497519856797499716149015804714742690480632125470059721510374721411912396600496466146713724038140770083062563809219701205043004985003060541518752738359488107314901878942753361265730416334257521571146000822536208537707551046062827725972776409655350198571761214256848313026393283607773374892252230835920609940124447631882292778358766651637274772672890331299528287923805184183516248977366759401719120523/89705935931640736054435665958355603666105269637286846920270754535858409557833593090467737996739075434073384340066361075570733968572830924251666997466463131943651576212131601716512210808728297541310312268072891279277741180221492438963404643653788385648777588477519992526654355656826749072543893902295589314505999521866637724914878073924517265792916385573262120956313119593045645584130298425932918447233624519091788895831518921785541012813773122128139837740838389444579709761121810563824706266786483867355535149670535370519186660463878956933866183764772568698232076718348561844175676558822228625330486281680709155960204297471764567223271946339967276468679277105049099271657402525462042999316585826708361924366371267283540914838936807821929792536920086833369488654495419832894723103060327583201006664853403393820665658372348298856794939191368484743912579697754609749723957215428617257924121813505819339013299749904436741349256782705805575183920941752497124692568577448929550202328397800085393521901834949947062229598867692296121301771382332552609928285981066807315141556493233773376338774242005213694403314871499682872115235067867034984445951890078561273685240099251193121223272768116451780961852630081865867412055773008665776379739413143013556553593270339154415803250338645129724026013666787799714443872100183858339996636561977113013845580358254952311888052085986993646714719907867305497661321765143175663186826875880493108546955342617077406588361497245270634294858402189890735870160623602568785881891114257837916795934329362172790439639274981659953359064462910863377505995632589915593104874328397575270625551028667040657218412879115337358331406102000849674724289585224337896624346175386960943003903315892367070633587178173628847411556771694069386872864944687749338512281841247494541772789682570994998925644284807666641793286224638572395198074668000756974296873261301737916400343467088538996700023534411692463699263927366175467536539162099898351243610629337905823438197669625009517391757288036988189662429858481249373241047757558373460797749450920304329015065512029530149688321371950518850993436032538093987324666626449956905865588634900414572363090553401399901669568935976426110779576422630731993850963795745274755138286209727344475523055521092426939208801069471276829863066237897432402675863141334740917457009648698863706557506474298135738974305982311841711761996935358610797872715917785013625250824415936042581487373129177977627904464583001566763286410635854418278354859937881411149289068838549615663711917925902691018631049110893438834218511634031207229182138988247516883374129509028391706257445617417089671194253088135938900422349436510165953942587462387079508699739231809014910265103016131644236693836591328228459003344621883859404601396933780851705101306641869403189040863829138538856880599255970799541249977279272579933623850127213321361291234780461852742377681255519702302518163409524704705506211377476035829296999319372727865485530619145487758179065630784780737174969759414200597953228540277710514698766401374972441320566722726513683775133456158731872148701887108027673358096580565530533193426558708959640671412354719391050066890011006999435506041567461865300404953758758169276072067278498605116115412954607730300098051018159177048688246196494512404579075782608830425951426824345914722015798284806393449400333939239045625618989876422951386142923379040080683405599720385053772711021342242737278692054725339532785322859538523074236842474735878998246059118539934310223102776189325651996200395815457449847756469363085873232669264576610294580277406878974237615880902489758918208430636768217942726549338769765473844286817502750247701897006150563957118057559737683032055414354643517871777513618772053769119449622213812100082252819064347348341725390290736074817513018248898815206730857498704206365170328481051527607478317285238698849947465350225353389888280097101123459763498512297041965882440535615642665587443182522246600442230433765601661218384005955208133197307854786981522461235191765453449115830581886740495317054082729198070834355953050884178257101417189214612025901773463787123585238693665152006414169885644767809294659329808450399978110355019196091439113139364922022798991847742214071347926290858094410788551740727885861137296758575726850882809600961910894951324471781241013974677364849838514236013164820762725745607421968556349359284270654783585182062591754038549808462683044771563741906280706948858205510069468274728276802713156129453559584268692944641480513443628278615722729368351695139562597510023574797562345946323074183413338326660202551099525930568568485640506659875832093483225505777634873553390350731413096613199248889768876727368912960744431124088740660073559188344751498694096645743289559227005701689869198713629021210193737418767536262362179651211841058606691685030492860319453406749303173576861102759291464699574005115818586517389248604655982016101755985811965758268947708174954570069859800058640057415705291853519367659725140232683946873532419066097788028555796760835406785340146637663796288738213003369237544229204716570902422128786265784104452454141655505933872943512454290691682634799342354626907567209714224547913917897825930471082946145269198623689029897497196793877996034986770188751383677155994247392423191843843178048689333134820665593241025679568373704648416899542575315319989100164035571548855980726087650404749789867896518506981418745049236255032791945726101496204936704418331248871746520191513860720312716801934290857719936440482576447853121584839779291754010373147733122621176064443155559644920703483755697985113421556360713881845074847759848898706545600223015756082727617115968636813911389037869790816181490281962288875911232536008122716029064960980831324729426532489096325410232316489597647250823454528897303934919853977922906619595462029742998998180435816421357092371679330795642021236424577909073621018200788806849294282046304964846836820473669693259705615681494361193029057532181341063163299774403382093311338596248376657310520272107830613601564798909788444599479632184743795343011752724088301313869480798365139563766417715845624491158242810210877345821215679906384873131400732282767794246200064309862764553091887447206447391778024611438596771479512182743157970402650130136398244967584289161499222793404162207043544162466394233242564101656278319892767966035407265630396780973680969061710868545289233423495762269306855550270592194073896636012804230612350917245687635308364583007271901320300893210255942639631866833012526633780882712266510662366039557827214053912665929537058171013616688498405927476455139756030690600212270640385561170203441933098536600178172037679819882146004723261254005225844922720138937842807784313429190220347036742645009851851562723907884168069443905789200932270631243594683660377886393794059455408276720768150064449810042588276756346935347042290304445003759991352567676637442744796588108269665665242320577448941703493896335484362626562760591377166720879820800
ACL2 !>(B-term 10)
-1024/641
ACL2 !>(B-term -10)
1/654336
ACL2 !>(+ (B-term 4000) (B-term -4000))
-2606493047907141848999736689241534405929096791501758758207599297548935640336870126976415004451812815070047915432445113969808382087253979612650035281625652909494111970078357888795985101839390718321512502921941919468953599089649088104987893709002429978347670527964406013607988801759062529341555253427906869400928079402081282502051614766374628798510881239920348801683287563605353420317260705385706019774131663168697691665015892231982714350341661624736781024632820662681829447803883427009975957797161453393669173230244297408629472546516817491643575234436542055692717966578599478138679711239982778690032669372878455599747300466797985028094112238612202338027431607815295627833980640860131464405716084056485758703140531953036452799559827934966032926651703166242854767590750373430914802091538027269657650520037441349340696299460298163802682953116234915917522583822204686239448070491321826456858330467698659763660062214540603287046651155666970174130840756969854325502390036796684029214025410376618324395255872678439707631915395765151583122921097751507375599185484816443931898274303834999077786841948119165878586353302445012808295220865583679513181791375508451661186606485135050703455346929838905659109790349221661141241751102367075552497669643733816852195771370774953216630040327437565501165656954655632857794867926442063392212211333326279170942994030167636492771326858166105098717229479687228569491269459258688160799421336086521070028199872640639743075481175762531251365269468760904278601607423415298957585319253497940779433929563980132574196412514771515664675661541855730081559379825245833421563380979011768434084270553561342620490791042612406473895352098256001462594246532327654097186107993792965655965971276518348248375164229351507458148698346386874340535084763671832116063995878329654118983261349743194719610303967438825545966592993473119147015618643822604080706134507851242710664472038914169926499854609863003257685653511599105549129948869771986387176718687615351558901599807036338341054200467935444060748023507109427015734270961189059648660554865141551706861464466112299306800603717557154849360675834211141677483678594190625089091973943311561252276600973875747576650562084684141364721701620450250251923438963540573099610051040468545357451620795519676996173120658762381308734375161215395681833732927799508734840078880406866358711250876578267866974529675780873272265157627068874288615280337108448211215164521840575/514099596438067809040517019752270631641767472826376379946193345594285201964005437492110332803712759292496689502747956098499425890075382669987511435647975177503242303331088669296829855068107763271426875564045731065064455152187217462649180362111981748898330504571409038617352195824741897855966834244099541823142130150305245655226287108216875075035489928540493955643984670835238911849477512713112102749871064106687066892786048122973465098345575426371052631821120604586227179435927688498866282483577840186577519567466986393638875688090902319563882862108121491614098145230337610328471591729656233058997786808789901490477846246949486811574302130443096910370212652575171056744898176476047130704240858018040280211013677833103965963455589213685406994192630585290814367921927086823535679951686586865905399795378505959799700619131972364976650935257343239943521826140678705517372111177301250850061311446048779616035884669415904659768517144733417545037184706511782217197622082909702036278789060050807164449955211136228244596664949597936815667502095771563692740845592735023042508883352992549374975197996569499161045929636823233112643400377416708070252871100471742708014296436698339118383166661433146177678452569527025664
ACL2 !>(B-term 4000)
-65910204671547155005194489711829568159200958054663638454640172512087846405641722755398760615860610165704703782403584115192234088471202906408655312262560920192723372221934444781644853213859969650182932764621247572444160916947079161878100046424613044730555192893770389566327204592915627930252158236423018182454119250039134058362344501053445522440447426735960763544100598825030629724291988809373346506393726167523982934972570272176085269018663516201417004079630846741823997363580472884470036215843312844433015329162434153030625088216782348662036264372836088668474121183376616708778409196109773469102280360101269421856134134224293180971064375697832937226950340073739879069858740573852196244133443335646189770642779209372303328648152463293000896691362895550104406143836806003017394865600844469987871768638269994846115463991278508330339863494531184608143823864189577630432321945807852673084783518724202514876395470437936494842117582658130454491946757245100284256105395244833594394716546160359892878199386043106185204700634563838053290705396893790217018057127273720902885754276024685817304512563662756302698196107285029886236333381720090778237547576983556757437730312397222963895277777106813612522878534554746880/13
ACL2 !>(B-term -4000)
5/39546122802928293003116693827097740895520574832798183072784103507252707843385033653239256369516366099422822269442150469115340453082721743845193187357536552115634023333160666868986911928315981790109759658772748543466496550168247497126860027854767826838333115736262233739796322755749376758151294941853810909472471550023480435017406700632067313464268456041576458126460359295018377834575193285624007903836235700514389760983542163305651161411198109720850202447778508045094398418148283730682021729505987706659809197497460491818375052930069409197221758623701653201084472710025970025267045517665864081461368216060761653113680480534575908582638625418699762336170204044243927441915244344311317746480066001387713862385667525623381997188891477975800538014817737330062643686302083601810436919360506681992723061182961996907669278394767104998203918096718710764886294318513746578259393167484711603850870111234521508925837282262761896905270549594878272695168054347060170553663237146900156636829927696215935726919631625863711122820380738302831974423238136274130210834276364232541731452565614811490382707538197653781618917664371017931741800029032054466942528546190134054462638187438333778337166666264088167513727120732848128
ACL2 !>(thm (implies (and (integerp h) (> h 0)) (< (/ (- (/ 2 (- 2 (* (/ 1 3200) h))) 1) (- 1 (/ 2 (+ 2 (* (/ 1 3200) h))))) (expt 2 (* 2 h)))))
Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (< 0 h))
         (< (+ (- (/ (+ 1 (- (* 2 (/ (+ 2 (* 1/3200 h))))))))
               (* 2 (/ (+ 2 (- (* 1/3200 h))))
                  (/ (+ 1 (- (* 2 (/ (+ 2 (* 1/3200 h)))))))))
            (expt 2 (* 2 h))))

*1 (Goal'') is pushed for proof by induction.

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( THM ...)
Rules: ((:definition fix)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite distributivity)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite unicity-of-1))
Time:  0.02 seconds (prove: 0.02, print: 0.00, other: 0.00)
Prover steps counted:  697

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (< 0 h))
         (< (+ (- (/ (+ 1 (- (* 2 (/ (+ 2 (* 1/3200 h))))))))
               (* 2 (/ (+ 2 (- (* 1/3200 h))))
                  (/ (+ 1 (- (* 2 (/ (+ 2 (* 1/3200 h)))))))))
            (expt 2 (* 2 h))))

ACL2 Error in ( THM ...):  See :DOC failure.

******** FAILED ********
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:13:14 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.01)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.34 seconds (prove: 0.00, print: 0.00, other: 4.34)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (< expt_gamma_minus_h 1)
                                             (> expt_gamma_minus_h 0)))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

Original clause(connect): (implies
                           (if (integerp h) (not (< h '1)) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (< '0 expt_gamma_minus_h)
                    (if (< expt_gamma_minus_h '1)
                        (if (< '0 expt_gamma_h)
                            (if (< expt_gamma_h '1)
                                (not (< h '1))
                                'nil)
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (binary-*
               expt_gamma_h
               ((lambda
                 (|var0|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                h))
              (binary-*
               expt_gamma_minus_h
               ((lambda
                 (|var1|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                (unary-- h))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (< '0 expt_gamma_minus_h)
                           (if (< expt_gamma_minus_h '1)
                               (if (< '0 expt_gamma_h)
                                   (if (< expt_gamma_h '1)
                                       (not (< h '1))
                                       'nil)
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (binary-*
                      expt_gamma_h
                      ((lambda
                        (|var0|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       h))
                     (binary-*
                      expt_gamma_minus_h
                      ((lambda
                        (|var1|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       (unary-- h))))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.14 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if (if (rationalp expt_gamma_minus_h)
                                        (if (rationalp expt_gamma_h)
                                            (integerp h)
                                            'nil)
                                        'nil)
                                    (if (< '0 expt_gamma_minus_h)
                                        (if (< expt_gamma_minus_h '1)
                                            (if (< '0 expt_gamma_h)
                                                (if (< expt_gamma_h '1)
                                                    (not (< h '1))
                                                    'nil)
                                                'nil)
                                            'nil)
                                        'nil)
                                    'nil)
                                (<
                                 (binary-+
                                  (binary-*
                                   expt_gamma_h
                                   ((lambda
                                     (|var0|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    h))
                                  (binary-*
                                   expt_gamma_minus_h
                                   ((lambda
                                     (|var1|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    (unary-- h))))
                                 '0)))
                              (b-term-expt h)
                              (b-term-expt (unary-- h))
                              h))
                            (implies
                             (if (integerp h) (not (< h '1)) 'nil)
                             (<
                              (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0)))
                           (implies
                                (if (integerp h)
                                    (if (equal expt_gamma_h (b-term-expt h))
                                        (not (< h '1))
                                        'nil)
                                    'nil)
                                (rationalp expt_gamma_h))
                           (implies (if (integerp h)
                                        (if (equal expt_gamma_minus_h
                                                   (b-term-expt (unary-- h)))
                                            (not (< h '1))
                                            'nil)
                                        'nil)
                                    (rationalp expt_gamma_minus_h)))

 Success!
Subgoal 3
Subgoal 3'
Subgoal 3''

([ A key checkpoint:

Subgoal 3''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

Normally we would attempt to prove Subgoal 3'' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg-lemma3 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite <-unary-/-positive-left)
        (:rewrite <-unary-/-positive-right)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite times-zero)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1751

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 3''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

ACL2 Error in ( defthm b-term-neg-lemma3 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.06 seconds (prove: 0.04, print: 0.00, other: 0.02)
Prover steps counted:  2630

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)


[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[17:31:23 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.44 seconds (prove: 0.00, print: 0.00, other: 0.44)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.51 seconds (prove: 0.00, print: 0.00, other: 4.51)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.02 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.01 seconds (prove: 0.01, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (defthm
            b-term-neg-lemma3
            (implies (and (integerp h) (>= h 1))
                     (< (+ (* (b-term-expt h) (b-term-rest h))
                           (* (b-term-expt (- h))
                              (b-term-rest (- h))))
                        0))
            :hints
            (("Goal" :clause-processor
                     (my-clause-processor
                          clause
                          '((:expand (b-term-rest gamma mu equ-c))
                            (:python-file "B-term-neg")
                            (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                   (expt_gamma_minus_h (b-term-expt (- h))
                                                       rationalp)))
                            (:hypothesize ((< expt_gamma_h 1)
                                           (> expt_gamma_h 0)
                                           (equal expt_gamma_minus_h
                                                  (/ 1 expt_gamma_h))))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

Original clause(connect): (implies
                           (if (integerp h) (not (< h '1)) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (equal expt_gamma_minus_h
                           (binary-* '1 (unary-/ expt_gamma_h)))
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1)
                            (not (< h '1))
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (binary-*
               expt_gamma_h
               ((lambda
                 (|var0|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                h))
              (binary-*
               expt_gamma_minus_h
               ((lambda
                 (|var1|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                (unary-- h))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (equal expt_gamma_minus_h
                                  (binary-* '1 (unary-/ expt_gamma_h)))
                           (if (< '0 expt_gamma_h)
                               (if (< expt_gamma_h '1)
                                   (not (< h '1))
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (binary-*
                      expt_gamma_h
                      ((lambda
                        (|var0|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       h))
                     (binary-*
                      expt_gamma_minus_h
                      ((lambda
                        (|var1|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       (unary-- h))))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 0.14 sec, 2,032 bytes
Expanded clause(connect): (((not
                             ((lambda
                               (expt_gamma_h expt_gamma_minus_h h)
                               (implies
                                (if
                                 (if (rationalp expt_gamma_minus_h)
                                     (if (rationalp expt_gamma_h)
                                         (integerp h)
                                         'nil)
                                     'nil)
                                 (if
                                   (equal
                                        expt_gamma_minus_h
                                        (binary-* '1 (unary-/ expt_gamma_h)))
                                   (if (< '0 expt_gamma_h)
                                       (if (< expt_gamma_h '1)
                                           (not (< h '1))
                                           'nil)
                                       'nil)
                                   'nil)
                                 'nil)
                                (<
                                 (binary-+
                                  (binary-*
                                   expt_gamma_h
                                   ((lambda
                                     (|var0|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var0| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    h))
                                  (binary-*
                                   expt_gamma_minus_h
                                   ((lambda
                                     (|var1|)
                                     (binary-+
                                      '-1
                                      (binary-*
                                       (binary-* '1
                                                 (unary-/ (binary-* '1 '1)))
                                       (binary-*
                                        (binary-+ '1 (binary-* '1 '1))
                                        (unary-/
                                         (binary-+
                                          '1
                                          (binary-*
                                           '1
                                           (binary-+
                                            (binary-* |var1| '1/3200)
                                            (binary-+
                                             (binary-*
                                              (binary-*
                                               '1
                                               (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                              (binary-+ '1 (binary-* '1 '1)))
                                             (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                    (unary-- h))))
                                 '0)))
                              (b-term-expt h)
                              (b-term-expt (unary-- h))
                              h))
                            (implies
                             (if (integerp h) (not (< h '1)) 'nil)
                             (<
                              (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0)))
                           (implies
                                (if (integerp h)
                                    (if (equal expt_gamma_h (b-term-expt h))
                                        (not (< h '1))
                                        'nil)
                                    'nil)
                                (rationalp expt_gamma_h))
                           (implies (if (integerp h)
                                        (if (equal expt_gamma_minus_h
                                                   (b-term-expt (unary-- h)))
                                            (not (< h '1))
                                            'nil)
                                        'nil)
                                    (rationalp expt_gamma_minus_h)))

 Success!
Subgoal 3
Subgoal 3'
Subgoal 3''

([ A key checkpoint:

Subgoal 3''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

Normally we would attempt to prove Subgoal 3'' by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg-lemma3 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Hint-events: ((:clause-processor my-clause-processor))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.04, print: 0.00, other: 0.00)
Prover steps counted:  1720

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 3''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

ACL2 Error in ( defthm b-term-neg-lemma3 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.06 seconds (prove: 0.05, print: 0.01, other: 0.00)
Prover steps counted:  2599

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(good-bye)

You have mail in /var/mail/yanpeng

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:53:09 yanpeng] DPLL $ acl
If 'acl' is not a typo you can use command-not-found to lookup the package that contains it, like this:
    cnf acl

[~/project/ACL2/DPLL] [ 9 files 64Kb ]
[14:53:12 yanpeng] DPLL $ acl2
Welcome to Clozure Common Lisp Version 1.9  (LinuxX8664)!

 ACL2 Version 6.4 built February 28, 2014  21:05:36.
 Copyright (C) 2014, Regents of the University of Texas
 ACL2 comes with ABSOLUTELY NO WARRANTY.  This is free software and you
 are welcome to redistribute it under certain conditions.  For details,
 see the LICENSE file distributed with ACL2.

 Initialized with (INITIALIZE-ACL2 'INCLUDE-BOOK *ACL2-PASS-2-FILES*).
 See the documentation topic note-6-4 for recent changes.
 Note: We have modified the prompt in some underlying Lisps to further
 distinguish it from the ACL2 prompt.

ACL2 Version 6.4.  Level 1.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>(ld "foo.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>> "ACL2"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "global" ...):  Unable
to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "global" ...):  There
is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp".


Summary
Form:  ( INCLUDE-BOOK "global" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/global.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "DPLL-functions" ...):
Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "DPLL-functions" ...):
There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp".


Summary
Form:  ( INCLUDE-BOOK "DPLL-functions" ...)
Rules: NIL
Warnings:  Uncertified and Compiled file
Time:  0.06 seconds (prove: 0.00, print: 0.00, other: 0.06)
 "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/DPLL-functions.lisp"
ACL2 !>>
Summary
Form:  ( INCLUDE-BOOK "arithmetic/top-with-meta" ...)
Rules: NIL
Time:  0.43 seconds (prove: 0.00, print: 0.00, other: 0.43)
 "/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/arithmetic/top-with-meta.lisp"
ACL2 !>>
ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  Unable to load compiled file for book
  /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp
because that book is not certified.  See :DOC include-book.  No load
was in progress for any parent book.


ACL2 Warning [Uncertified] in ( INCLUDE-BOOK "../smtlink/SMT-connect"
...):  There is no certificate on file for 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp".


TTAG NOTE: Adding ttag :MY-CL-PROC from book /ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.

ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-translator" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-translator.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "SMT-formula" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-formula.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./SMT-run" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-run.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( INCLUDE-BOOK "./config" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/config.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-interpreter"
...):  Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-interpreter.lisp"
instead of the corresponding compiled file, because the compiled file
does not exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-function" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-function.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./SMT-extract" ...):
Attempting to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-extract.lisp" instead
of the corresponding compiled file, because the compiled file does
not exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


ACL2 Warning [Compiled file] in ( include-book "./helper" ...):  Attempting
to load source file 
"/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/helper.lisp" instead of
the corresponding compiled file, because the compiled file does not
exist.


Summary
Form:  ( include-book "../smtlink/SMT-connect" ...)
Rules: nil
Warnings:  Uncertified and Compiled file
Time:  4.39 seconds (prove: 0.00, print: 0.00, other: 4.39)
 "/ubc/cs/home/y/yanpeng/project/ACL2/smtlink/SMT-connect.lisp"
ACL2 !>>
The event ( table acl2-defaults-table ...) is redundant.  See :DOC
redundant-events.
ACL2 !>> t
ACL2 !>>
Since b-term-expt is non-recursive, its admission is trivial.  We observe
that the type of b-term-expt is described by the theorem 
(and (rationalp (b-term-expt h)) (< 0 (b-term-expt h))).  We used primitive
type reasoning and the :type-prescription rules 
expt-type-prescription-nonzero, expt-type-prescription-positive, 
expt-type-prescription-rationalp and gamma.

Summary
Form:  ( defun b-term-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-expt
ACL2 !>>
Since b-term-rest is non-recursive, its admission is trivial.  We observe
that the type of b-term-rest is described by the theorem 
(acl2-numberp (b-term-rest h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term-rest ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term-rest
ACL2 !>>
Since b-term is non-recursive, its admission is trivial.  We observe
that the type of b-term is described by the theorem 
(acl2-numberp (b-term h)).  We used primitive type reasoning.

Summary
Form:  ( defun b-term ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-term
ACL2 !>>
For the admission of b-sum we will use the relation o< (which is known
to be well-founded on the domain recognized by o-p) and the measure
(if (or (not (integerp h_lo))
        (not (integerp h_hi))
        (< h_hi h_lo))
    0 (+ 1 h_hi (- h_lo))).
  The non-trivial part of the measure conjecture is

Goal
(and (o-p (if (or (not (integerp h_lo))
                  (not (integerp h_hi))
                  (< h_hi h_lo))
              0 (+ 1 h_hi (- h_lo))))
     (implies (not (or (not (integerp h_hi))
                       (not (integerp h_lo))
                       (< h_hi h_lo)))
              (o< (if (or (not (integerp h_lo))
                          (not (integerp (+ -1 h_hi)))
                          (< (+ -1 h_hi) h_lo))
                      0 (+ 1 (+ -1 h_hi) (- h_lo)))
                  (if (or (not (integerp h_lo))
                          (not (integerp h_hi))
                          (< h_hi h_lo))
                      0 (+ 1 h_hi (- h_lo)))))).
Subgoal 2

Splitter note (see :DOC splitter) for Subgoal 2 (4 subgoals).
  if-intro: ((:definition not) (:definition o-p))

Subgoal 2.4
Subgoal 2.3
Subgoal 2.2
Subgoal 2.1
Subgoal 1

Splitter note (see :DOC splitter) for Subgoal 1 (2 subgoals).
  if-intro: ((:definition not) (:definition o<))

Subgoal 1.2
Subgoal 1.1

Q.E.D.

That completes the proof of the measure theorem for b-sum.  Thus, we
admit this function under the principle of definition.  We observe
that the type of b-sum is described by the theorem 
(acl2-numberp (b-sum h_lo h_hi)).  We used primitive type reasoning
and the :type-prescription rule b-term.

Summary
Form:  ( defun b-sum ...)
Rules: ((:definition fix)
        (:definition not)
        (:definition o-finp)
        (:definition o-p)
        (:definition o<)
        (:executable-counterpart natp)
        (:executable-counterpart not)
        (:executable-counterpart tau-system)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:rewrite associativity-of-+)
        (:rewrite minus-cancellation-on-left)
        (:rewrite natp-rw)
        (:type-prescription b-term))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition not)
             (:definition o-p)
             (:definition o<))
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  509
 b-sum
ACL2 !>>
Since b-expt is non-recursive, its admission is trivial.  We observe
that the type of b-expt is described by the theorem 
(and (rationalp (b-expt n)) (< 0 (b-expt n))).  We used primitive type
reasoning and the :type-prescription rules expt-type-prescription-nonzero,
expt-type-prescription-positive, expt-type-prescription-rationalp and
gamma.

Summary
Form:  ( defun b-expt ...)
Rules: ((:fake-rune-for-type-set nil)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp)
        (:type-prescription gamma))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b-expt
ACL2 !>>
Since b is non-recursive, its admission is trivial.  We observe that
the type of b is described by the theorem (acl2-numberp (b n)).  We
used primitive type reasoning.

Summary
Form:  ( defun b ...)
Rules: ((:fake-rune-for-type-set nil))
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
 b
ACL2 !>>
To verify that the four encapsulated events correctly extend the current
theory we will evaluate them.  The theory thus constructed is only
ephemeral.

Encapsulated Events:


ACL2 !>>>(local (defthm b-term-neg-lemma1
                        (equal (b-term h)
                               (* (b-term-expt h) (b-term-rest h)))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma1 ...):  A :rewrite
rule generated from b-term-neg-lemma1 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma1 ...)
Rules: ((:definition b-term)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Non-rec
Time:  0.00 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  422
b-term-neg-lemma1


ACL2 !>>>(local (defthm b-term-neg-lemma2
                        (equal (b-term (- h))
                               (* (b-term-expt (- h))
                                  (b-term-rest (- h))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma2 ...):  A :rewrite
rule generated from b-term-neg-lemma2 will be triggered only by terms
containing the non-recursive function symbol b-term.  Unless this function
is disabled, this rule is unlikely ever to be used.


ACL2 Warning [Subsume] in ( defthm b-term-neg-lemma2 ...):  The previously
added rule b-term-neg-lemma1 subsumes a newly proposed :rewrite rule
generated from b-term-neg-lemma2, in the sense that the old rule rewrites
a more general target.  Because the new rule will be tried first, it
may nonetheless find application.

Goal'

Q.E.D.

Summary
Form:  ( defthm b-term-neg-lemma2 ...)
Rules: ((:definition b-term-expt)
        (:definition b-term-rest)
        (:definition fix)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart gamma)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:fake-rune-for-type-set nil)
        (:rewrite b-term-neg-lemma1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Warnings:  Subsume and Non-rec
Time:  0.01 seconds (prove: 0.00, print: 0.00, other: 0.00)
Prover steps counted:  457
b-term-neg-lemma2


ACL2 !>>>(local
          (defthm
              b-term-neg-lemma3
              (implies (and (integerp h) (>= h 1))
                       (< (+ (* (b-term-expt h) (b-term-rest h))
                             (* (b-term-expt (- h))
                                (b-term-rest (- h))))
                          0))
              :hints
              (("Goal" :clause-processor
                       (my-clause-processor
                            clause
                            '((:expand (b-term-rest gamma mu equ-c))
                              (:python-file "B-term-neg")
                              (:let ((expt_gamma_h (b-term-expt h) rationalp)
                                     (expt_gamma_minus_h (b-term-expt (- h))
                                                         rationalp)))
                              (:hypothesize ((< expt_gamma_h 1)
                                             (> expt_gamma_h 0)
                                             (equal expt_gamma_minus_h
                                                    (/ expt_gamma_h))))))))))

ACL2 Warning [Non-rec] in ( defthm b-term-neg-lemma3 ...):  A :rewrite
rule generated from b-term-neg-lemma3 will be triggered only by terms
containing the non-recursive function symbols b-term-expt and b-term-rest.
Unless these functions are disabled, this rule is unlikely ever to
be used.

Original clause(connect): (implies
                           (if (integerp h) (not (< h '1)) 'nil)
                           (< (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
formal: nil,
body: (binary-* '1 (unary-/ (binary-* '1 '1)))
formal: nil,
body: (binary-+ (binary-* (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                (unary-- (binary-* '1 (unary-/ '1))))
rewritten: (implies
            (if (if (rationalp expt_gamma_minus_h)
                    (if (rationalp expt_gamma_h)
                        (integerp h)
                        'nil)
                    'nil)
                (if (equal expt_gamma_minus_h
                           (unary-/ expt_gamma_h))
                    (if (< '0 expt_gamma_h)
                        (if (< expt_gamma_h '1)
                            (not (< h '1))
                            'nil)
                        'nil)
                    'nil)
                'nil)
            (<
             (binary-+
              (binary-*
               expt_gamma_h
               ((lambda
                 (|var0|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var0| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                h))
              (binary-*
               expt_gamma_minus_h
               ((lambda
                 (|var1|)
                 (binary-+
                  '-1
                  (binary-*
                   (binary-* '1 (unary-/ (binary-* '1 '1)))
                   (binary-*
                    (binary-+ '1 (binary-* '1 '1))
                    (unary-/
                     (binary-+
                      '1
                      (binary-*
                       '1
                       (binary-+
                        (binary-* |var1| '1/3200)
                        (binary-+
                         (binary-*
                          (binary-* '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                          (binary-+ '1 (binary-* '1 '1)))
                         (unary-- (binary-* '1 (unary-/ '1))))))))))))
                (unary-- h))))
             '0))
Expanded(SMT-z3): (implies
                   (if (if (rationalp expt_gamma_minus_h)
                           (if (rationalp expt_gamma_h)
                               (integerp h)
                               'nil)
                           'nil)
                       (if (equal expt_gamma_minus_h
                                  (unary-/ expt_gamma_h))
                           (if (< '0 expt_gamma_h)
                               (if (< expt_gamma_h '1)
                                   (not (< h '1))
                                   'nil)
                               'nil)
                           'nil)
                       'nil)
                   (<
                    (binary-+
                     (binary-*
                      expt_gamma_h
                      ((lambda
                        (|var0|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var0| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       h))
                     (binary-*
                      expt_gamma_minus_h
                      ((lambda
                        (|var1|)
                        (binary-+
                         '-1
                         (binary-*
                          (binary-* '1 (unary-/ (binary-* '1 '1)))
                          (binary-*
                           (binary-+ '1 (binary-* '1 '1))
                           (unary-/
                            (binary-+
                             '1
                             (binary-*
                              '1
                              (binary-+
                               (binary-* |var1| '1/3200)
                               (binary-+
                                (binary-*
                                 (binary-*
                                    '1
                                    (unary-/ (binary-* '1 (binary-* '1 '1))))
                                 (binary-+ '1 (binary-* '1 '1)))
                                (unary-- (binary-* '1 (unary-/ '1))))))))))))
                       (unary-- h))))
                    '0))
Final index number: 2
proved
; Z3: `python z3_files/B-term-neg.py`: 1.23 sec, 2,032 bytes
Expanded clause(connect): ((not
                            ((lambda
                              (expt_gamma_h expt_gamma_minus_h h)
                              (implies
                               (if (if (rationalp expt_gamma_minus_h)
                                       (if (rationalp expt_gamma_h)
                                           (integerp h)
                                           'nil)
                                       'nil)
                                   (if (equal expt_gamma_minus_h
                                              (unary-/ expt_gamma_h))
                                       (if (< '0 expt_gamma_h)
                                           (if (< expt_gamma_h '1)

					   (not (< h '1))
                                               'nil)
                                           'nil)
                                       'nil)
                                   'nil)
                               (<
                                (binary-+
                                 (binary-*
                                  expt_gamma_h
                                  ((lambda
                                    (|var0|)
                                    (binary-+
                                     '-1
                                     (binary-*
                                      (binary-* '1
                                                (unary-/ (binary-* '1 '1)))
                                      (binary-*
                                       (binary-+ '1 (binary-* '1 '1))
                                       (unary-/
                                        (binary-+
                                         '1
                                         (binary-*
                                          '1
                                          (binary-+
                                           (binary-* |var0| '1/3200)
                                           (binary-+
                                            (binary-*
                                             (binary-*
                                              '1
                                              (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                             (binary-+ '1 (binary-* '1 '1)))
                                            (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                   h))
                                 (binary-*
                                  expt_gamma_minus_h
                                  ((lambda
                                    (|var1|)
                                    (binary-+
                                     '-1
                                     (binary-*
                                      (binary-* '1
                                                (unary-/ (binary-* '1 '1)))
                                      (binary-*
                                       (binary-+ '1 (binary-* '1 '1))
                                       (unary-/
                                        (binary-+
                                         '1
                                         (binary-*
                                          '1
                                          (binary-+
                                           (binary-* |var1| '1/3200)
                                           (binary-+
                                            (binary-*
                                             (binary-*
                                              '1
                                              (unary-/
                                                (binary-* '1
                                                          (binary-* '1 '1))))
                                             (binary-+ '1 (binary-* '1 '1)))
                                            (unary--
                                                 (binary-*
                                                      '1
                                                      (unary-/ '1))))))))))))
                                   (unary-- h))))
                                '0)))
                             (b-term-expt h)
                             (b-term-expt (unary-- h))
                             h))
                           (implies
                            (if (integerp h) (not (< h '1)) 'nil)
                            (<
                              (binary-+ (binary-* (b-term-expt h)
                                                  (b-term-rest h))
                                        (binary-* (b-term-expt (unary-- h))
                                                  (b-term-rest (unary-- h))))
                              '0)))

 Success!
Subgoal 2
Subgoal 2'
Subgoal 1
Subgoal 1'

Splitter note (see :DOC splitter) for Subgoal 1' (3 subgoals).
  if-intro: ((:definition fix) (:definition not))

Subgoal 1.3

([ A key checkpoint:

Subgoal 1.3
(implies (not (integerp h))
         (< (+ (* 2 (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (+ 2 (- (* 1/3200 h))))))
            2))

Normally we would attempt to prove Subgoal 1.3 by induction.  However,
we prefer in this instance to focus on the original input conjecture
rather than this simplified special case.  We therefore abandon our
previous work on this conjecture and reassign the name *1 to the original
conjecture.  (See :DOC otf-flg.)

])

No induction schemes are suggested by *1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( defthm b-term-neg-lemma3 ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary-/)
        (:fake-rune-for-type-set nil)
        (:rewrite <-+-negative-0-1)
        (:rewrite associativity-of-+)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite equal-/-/)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive)
        (:type-prescription expt-type-prescription-rationalp))
Hint-events: ((:clause-processor my-clause-processor))
Splitter rules (see :DOC splitter):
  if-intro: ((:definition fix) (:definition not))
Warnings:  Non-rec
Time:  0.04 seconds (prove: 0.03, print: 0.00, other: 0.00)
Prover steps counted:  1658

---
The key checkpoint goal, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint before reverting to proof by induction: ***

Subgoal 1.3
(implies (not (integerp h))
         (< (+ (* 2 (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (+ 2 (- (* 1/3200 h))))))
            2))

ACL2 Error in ( defthm b-term-neg-lemma3 ...):  See :DOC failure.

******** FAILED ********

ACL2 Warning in ( ENCAPSULATE NIL (local ...) ...):  The attempted
encapsulate has failed while trying to establish the admissibility
of one of the (local or non-local) forms in the body of the ENCAPSULATE.


Summary
Form:  ( ENCAPSULATE NIL (local ...) ...)
Rules: nil
Warnings:  Subsume and Non-rec
Time:  0.06 seconds (prove: 0.04, print: 0.00, other: 0.01)
Prover steps counted:  2537

ACL2 Error in ( ENCAPSULATE NIL (local ...) ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>(ld "x.lisp")

ACL2 Version 6.4.  Level 2.  Cbd "/ubc/cs/home/y/yanpeng/project/ACL2/DPLL/".
System books directory 
"/ubc/cs/research/isd/users/software/ACL2/acl2-sources/books/".
Type :help for help.
Type (good-bye) to quit completely out of ACL2.

ACL2 !>>Goal'
Goal''

([ A key checkpoint:

Goal''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

*1 (Goal'') is pushed for proof by induction.

])

Perhaps we can prove *1 by induction.  Four induction schemes are suggested
by this conjecture.  Subsumption reduces that number to one.  

We will induct according to a scheme suggested by (expt '2 h).  This
suggestion was produced using the :induction rule expt.  If we let
(:p h) denote *1 above then the induction scheme we'll use is
(and (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (<= h 0)
                   (:p (+ h 1)))
              (:p h))
     (implies (and (not (zip h))
                   (not (= (fix 2) 0))
                   (< 0 h)
                   (:p (+ h -1)))
              (:p h))
     (implies (and (not (zip h)) (= (fix 2) 0))
              (:p h))
     (implies (zip h) (:p h))).
This induction is justified by the same argument used to admit expt.
When applied to the goal at hand the above induction scheme produces
eight nontautological subgoals.
Subgoal *1/8
Subgoal *1/7
Subgoal *1/6
Subgoal *1/5
Subgoal *1/5'
Subgoal *1/5''
Subgoal *1/5'''
Subgoal *1/5'4'
Subgoal *1/5'5'
Subgoal *1/5'6'
Subgoal *1/5'7'
Subgoal *1/5'8'
Subgoal *1/5'9'

([ A key checkpoint while proving *1 (descended from Goal''):

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (- (/ (expt 2 (+ -1 h))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h))))
                    (* 2 (/ (expt 2 (+ -1 h)))
                       (/ (+ 6401/3200 (- (* 1/3200 h))))))
                 (expt 2 (+ -1 h)))
              (integerp h)
              (<= 1 h))
         (< (+ (- (* 1/2 (/ (expt 2 (+ -1 h)))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h))))
               (* (/ (expt 2 (+ -1 h)))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (* 2 (expt 2 (+ -1 h)))))

*1.1 (Subgoal *1/5'9') is pushed for proof by induction.

])
Subgoal *1/4
Subgoal *1/4'
Subgoal *1/3
Subgoal *1/2
Subgoal *1/1

So we now return to *1.1, which is

(implies (and (rationalp k)
              (< 0 k)
              (rationalp s)
              (< s 0)
              (integerp j)
              (< 0 j)
              (rationalp r)
              (< 0 r)
              (integerp i)
              (<= 0 i)
              (< 0 h)
              (< (+ (- k)
                    (* 2 j (/ (+ 6399/3200 r)))
                    (* 2 k (/ (+ 6401/3200 s))))
                 j)
              (integerp h)
              (<= 1 h))
         (< (+ (- (* 1/2 k))
               (* k (/ (+ 2 s)))
               (* 4 j (/ (+ 2 r))))
            (* 2 j))).

No induction schemes are suggested by *1.1.  Consequently, the proof
attempt has failed.

Summary
Form:  ( THM ...)
Rules: ((:compound-recognizer zip-compound-recognizer)
        (:definition b-term-expt)
        (:definition b-term-rest)
        (:definition expt)
        (:definition fix)
        (:definition not)
        (:definition synp)
        (:executable-counterpart <)
        (:executable-counterpart =)
        (:executable-counterpart acl2-numberp)
        (:executable-counterpart binary-*)
        (:executable-counterpart binary-+)
        (:executable-counterpart equ-c)
        (:executable-counterpart equal)
        (:executable-counterpart expt)
        (:executable-counterpart fix)
        (:executable-counterpart gamma)
        (:executable-counterpart integerp)
        (:executable-counterpart mu)
        (:executable-counterpart not)
        (:executable-counterpart rationalp)
        (:executable-counterpart unary--)
        (:executable-counterpart unary-/)
        (:executable-counterpart zip)
        (:fake-rune-for-linear nil)
        (:fake-rune-for-type-set nil)
        (:generalize expt-type-prescription-integerp)
        (:generalize expt-type-prescription-nonzero)
        (:generalize expt-type-prescription-positive)
        (:generalize expt-type-prescription-rationalp)
        (:induction expt)
        (:rewrite <-+-negative-0-1)
        (:rewrite commutativity-2-of-*)
        (:rewrite commutativity-2-of-+)
        (:rewrite commutativity-of-*)
        (:rewrite commutativity-of-+)
        (:rewrite distributivity)
        (:rewrite distributivity-of-/-over-*)
        (:rewrite distributivity-of-minus-over-+)
        (:rewrite expt-minus)
        (:rewrite fold-consts-in-*)
        (:rewrite fold-consts-in-+)
        (:rewrite functional-commutativity-of-expt-/-base)
        (:rewrite functional-commutativity-of-minus-*-left)
        (:rewrite functional-commutativity-of-minus-*-right)
        (:rewrite functional-self-inversion-of-/)
        (:rewrite functional-self-inversion-of-minus)
        (:rewrite unicity-of-1)
        (:type-prescription expt-type-prescription-integerp)
        (:type-prescription expt-type-prescription-nonzero)
        (:type-prescription expt-type-prescription-positive))
Time:  0.16 seconds (prove: 0.15, print: 0.01, other: 0.00)
Prover steps counted:  7311

---
The key checkpoint goals, below, may help you to debug this failure.
See :DOC failure and see :DOC set-checkpoint-summary-limit.
---

*** Key checkpoint at the top level: ***

Goal''
(implies (and (integerp h) (<= 1 h))
         (< (+ (- (/ (expt 2 h)))
               (* 2 (expt 2 h) (/ (+ 2 (* 1/3200 h))))
               (* 2 (/ (expt 2 h))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (expt 2 h)))

*** Key checkpoint under a top-level induction ***

Subgoal *1/5'''
(implies (and (< 0 h)
              (< (+ (- (/ (expt 2 (+ -1 h))))
                    (* 2 (expt 2 (+ -1 h))
                       (/ (+ 6399/3200 (* 1/3200 h))))
                    (* 2 (/ (expt 2 (+ -1 h)))
                       (/ (+ 6401/3200 (- (* 1/3200 h))))))
                 (expt 2 (+ -1 h)))
              (integerp h)
              (<= 1 h))
         (< (+ (- (* 1/2 (/ (expt 2 (+ -1 h)))))
               (* 4 (expt 2 (+ -1 h))
                  (/ (+ 2 (* 1/3200 h))))
               (* (/ (expt 2 (+ -1 h)))
                  (/ (+ 2 (- (* 1/3200 h))))))
            (* 2 (expt 2 (+ -1 h)))))

ACL2 Error in ( THM ...):  See :DOC failure.

******** FAILED ********
 (:stop-ld 2)
ACL2 !>